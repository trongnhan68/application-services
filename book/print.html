<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cross-platform Rust Components</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="shared/a-s.css">
        
        <link rel="stylesheet" href="shared/mermaid.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">application-services Rust Components</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">1.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building.html"><strong aria-hidden="true">1.1.</strong> Building</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="howtos/locally-published-components-in-fenix.html"><strong aria-hidden="true">1.1.1.</strong> How to use the local development autopublish flow for Fenix</a></li><li class="chapter-item expanded "><a href="howtos/locally-published-components-in-ios.html"><strong aria-hidden="true">1.1.2.</strong> How to use the local development flow for Firefox iOS</a></li><li class="chapter-item expanded "><a href="howtos/locally-building-jna.html"><strong aria-hidden="true">1.1.3.</strong> How to locally build JNA</a></li></ol></li><li class="chapter-item expanded "><a href="howtos/testing-a-rust-component.html"><strong aria-hidden="true">1.2.</strong> How we test Rust Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="howtos/smoke-testing-app-services.html"><strong aria-hidden="true">1.2.1.</strong> How to integration (smoke) test application-services</a></li><li class="chapter-item expanded "><a href="design/test-faster.html"><strong aria-hidden="true">1.2.2.</strong> Writing efficient tests</a></li></ol></li><li class="chapter-item expanded "><a href="dependency-management.html"><strong aria-hidden="true">1.3.</strong> Dependency management</a></li><li class="chapter-item expanded "><a href="howtos/adding-a-new-component.html"><strong aria-hidden="true">1.4.</strong> How to add a new component</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="howtos/building-a-rust-component.html"><strong aria-hidden="true">1.4.1.</strong> How to build a new syncable component</a></li><li class="chapter-item expanded "><a href="naming-conventions.html"><strong aria-hidden="true">1.4.2.</strong> Naming Conventions</a></li><li class="chapter-item expanded "><a href="howtos/converting-a-component-to-uniffi.html"><strong aria-hidden="true">1.4.3.</strong> How to convert a Rust Component to Uniffi</a></li><li class="chapter-item expanded "><a href="howtos/when-to-use-what-in-the-ffi.html"><strong aria-hidden="true">1.4.4.</strong> How to know what to use when in the FFI</a></li><li class="chapter-item expanded "><a href="android-faqs.html"><strong aria-hidden="true">1.4.5.</strong> How to use Rust Components in Android</a></li><li class="chapter-item expanded "><a href="howtos/consuming-rust-components-on-ios.html"><strong aria-hidden="true">1.4.6.</strong> How to use Rust Components on iOS</a></li></ol></li><li class="chapter-item expanded "><a href="logging.html"><strong aria-hidden="true">1.5.</strong> Logging</a></li></ol></li><li class="chapter-item expanded "><a href="howtos/cut-a-new-release.html"><strong aria-hidden="true">2.</strong> How to cut a new release</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/megazords.html"><strong aria-hidden="true">2.1.</strong> How we distribute the application-services library</a></li><li class="chapter-item expanded "><a href="build-and-publish-pipeline.html"><strong aria-hidden="true">2.2.</strong> CI Publishing tools and flow</a></li><li class="chapter-item expanded "><a href="howtos/upgrading-nss-guide.html"><strong aria-hidden="true">2.3.</strong> How to upgrade NSS</a></li></ol></li><li class="chapter-item expanded "><a href="metrics/index.html"><strong aria-hidden="true">3.</strong> Metrics - (Glean Telemetry)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="metrics/logins/metrics.html"><strong aria-hidden="true">3.1.</strong> Logins</a></li><li class="chapter-item expanded "><a href="metrics/places/metrics.html"><strong aria-hidden="true">3.2.</strong> Places</a></li></ol></li><li class="chapter-item expanded "><a href="adding-docs.html"><strong aria-hidden="true">4.</strong> Adding to these documents</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Cross-platform Rust Components</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/mozilla/application-services" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="application-services-rust-components"><a class="header" href="#application-services-rust-components">application-services Rust Components</a></h1>
<p>Application Services (a-s) is collection of Rust Components that are used to enable Firefox applications to integrate with Firefox accounts, sync, experimentation, etc. Each component is built using a core of shared code written in Rust, wrapped with native language bindings for different platforms.</p>
<p>To contact us you can:</p>
<ul>
<li>Find us in the chat <a href="https://chat.mozilla.org/#/room/#rust-components:mozilla.org">#rust-components:mozilla.org</a> (<a href="https://wiki.mozilla.org/Matrix#Connect_to_Matrix">How to connect</a>)</li>
<li>To report issues or request changes, file a bug in <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Firefox&amp;component=Sync">Bugzilla for Firefox :: Sync</a></li>
</ul>
<p>The source code is available <a href="https://github.com/mozilla/application-services/">on GitHub</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The Application Services Source Code is subject to the terms of the Mozilla Public License v2.0.
You can obtain a copy of the MPL at <a href="https://mozilla.org/MPL/2.0/">https://mozilla.org/MPL/2.0/</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-application-services"><a class="header" href="#contributing-to-application-services">Contributing to Application Services</a></h1>
<p>Anyone is welcome to help with the Application Services project. Feel free to get in touch with other community members on Matrix, the mailing list or through issues here on GitHub.</p>
<ul>
<li>Matrix: <a href="https://chat.mozilla.org/#/room/#sync:mozilla.org">#sync:mozilla.org</a></li>
<li>Mailing list: <a href="https://mail.mozilla.org/listinfo/sync-dev">https://mail.mozilla.org/listinfo/sync-dev</a></li>
<li>and of course, <a href="https://github.com/mozilla/application-services/issues">the issues list</a></li>
</ul>
<p>Participation in this project is governed by the
<a href="https://www.mozilla.org/en-US/about/governance/policies/participation/">Mozilla Community Participation Guidelines</a>.</p>
<h2 id="bug-reports"><a class="header" href="#bug-reports">Bug Reports</a></h2>
<p>You can file issues here on GitHub. Please try to include as much information as you can and under what conditions
you saw the issue.</p>
<h2 id="building-the-project"><a class="header" href="#building-the-project">Building the project</a></h2>
<p>Build instructions are available <a href="building.html">here</a>. Do not hesitate to let us know which pain-points you had with setting up your environment!</p>
<h2 id="finding-issues"><a class="header" href="#finding-issues">Finding issues</a></h2>
<p>Below are a few different queries you can use to find appropriate issues to work on.  Feel free to reach out if you need any additional clarification before picking up an issue.</p>
<ul>
<li><strong><a href="https://github.com/mozilla/application-services/issues?q=is%3Aopen+is%3Aissue+label%3Agood-first-issue">good first issues</a></strong> -  If you are a new contributor, search for issues labeled <code>good-first-issue</code></li>
<li><strong><a href="https://github.com/mozilla/application-services/labels/good-second-issue">good second issues</a></strong> Once you've got that first PR approved and you are looking for something a little more challenging, we are keeping a list of next-level issues. Search for the <code>good-second-issue</code> label.</li>
<li><strong><a href="https://github.com/mozilla/application-services/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+%22Epic%3A+papercuts%22+">papercuts</a></strong> A collection of smaller sized issues that may be a bit more advanced than a first or second issue.</li>
<li><strong><a href="https://github.com/mozilla/application-services/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+%22Epic%3A+important+not+urgent%22">important, but not urgent</a></strong> - For more advanced contributors, we have a collection of issues that we consider important and would like to resolve sooner, but work isn't currently prioritized by the core team.</li>
</ul>
<h2 id="sending-pull-requests"><a class="header" href="#sending-pull-requests">Sending Pull Requests</a></h2>
<p>Patches should be submitted as <a href="https://help.github.com/articles/about-pull-requests/">pull requests</a> (PRs).</p>
<p>Before submitting a PR:</p>
<ul>
<li>Your patch should include new tests that cover your changes, or be accompanied by explanation for why it doesn't need any. It is your and your reviewer's responsibility to ensure your patch includes adequate tests.
<ul>
<li>Consult the <a href="./howtos/testing-a-rust-component.html">testing guide</a> for some tips on writing effective tests.</li>
</ul>
</li>
<li>Your code should pass all the automated tests before you submit your PR for review.
<ul>
<li>Before pushing your changes, run <code>./automation/tests.py changes</code>.  This will calculate which components were changed and run test suites against them, as well as linters and formatters.  Because it runs a limited set of tests, it should execute in a fairly reasonable amount of time.</li>
<li>After you open a PR, our CI system will run a full test suite.  It's possible that this step will result in errors not caught with changes mode, so make sure to check the results.</li>
<li>&quot;Work in progress&quot; pull requests are welcome, but should be clearly labeled as such and should not be merged until all tests pass and the code has been reviewed.
<ul>
<li>You can label pull requests as &quot;Work in progress&quot; by using the Github PR UI to indicate this PR is a draft (<a href="https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests#draft-pull-requests">learn more about draft PRs</a>).</li>
</ul>
</li>
</ul>
</li>
<li>Run <code>cargo fmt</code> to ensure your Rust code is correctly formatted. You should run this command after running tests and before pushing changes so that any fixes for failed tests are included.
<ul>
<li>If you have modified any Swift code, also run <code>swiftformat --swiftversion 4</code> on the modified code.</li>
</ul>
</li>
<li>Your patch should include a changelog entry in <a href="../CHANGES_UNRELEASED.html">CHANGES_UNRELEASED.md</a> or an explanation of why
it does not need one. Any breaking changes to Swift or Kotlin binding APIs should be noted explicitly</li>
<li>If your patch adds new dependencies, they must follow our <a href="./dependency-management.html">dependency management guidelines</a>.
Please include a summary of the due dilligence applied in selecting new dependencies.</li>
</ul>
<p>When submitting a PR:</p>
<ul>
<li>You agree to license your code under the project's open source license (<a href="/LICENSE">MPL 2.0</a>).</li>
<li>Base your branch off the current <code>main</code> branch.</li>
<li>Add both your code and new tests if relevant.</li>
<li>Please do not include merge commits in pull requests; include only commits with the new relevant code.</li>
<li>We encourage you to <a href="https://help.github.com/articles/managing-commit-signature-verification">GPG sign your commits</a>.</li>
</ul>
<h2 id="code-review"><a class="header" href="#code-review">Code Review</a></h2>
<p>This project is production Mozilla code and subject to our <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Committing_Rules_and_Responsibilities">engineering practices and quality standards</a>. Every patch must be peer reviewed by a member of the Application Services team.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/contributing.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="building-application-services"><a class="header" href="#building-application-services">Building Application Services</a></h1>
<p>When working on application-services Rust Components it's important to set up your environment for both building the application-services library, but also for Android or iOS as appropriate to test your changes in our clients.</p>
<h2 id="first-time-builds"><a class="header" href="#first-time-builds">First time builds</a></h2>
<p>Building for the first time is more complicated than a typical Rust project.
To build for an end-to-end experience that enables you to test changes in our
client applications like Fenix and Firefox iOS, there are a number of build
systems required for all the dependencies. The initial setup is likely to take
a number of hours to complete.</p>
<h2 id="building-the-rust-components"><a class="header" href="#building-the-rust-components">Building the Rust Components</a></h2>
<p><em>Complete this section before moving to the android/iOS build instructions.</em></p>
<ol>
<li>Install Rust: install <a href="https://www.rust-lang.org/tools/install">via rustup</a></li>
<li>Install your system dependencies: - install via the instructions below for <a href="building.html#linux">Linux</a>, <a href="building.html#macos">MacOS</a> or <a href="building.html#windows">Windows</a></li>
<li>Check dependencies, environment variables and test
<ol>
<li>Run: <code>./libs/verify-desktop-environment.sh</code></li>
<li>Run: <code>cargo test</code></li>
</ol>
</li>
</ol>
<p>Once you have successfully run <code>./libs/verify-desktop-environment.sh</code> and <code>cargo test</code> you can move to the <strong>Building for Fenix</strong> and <strong>Building for iOS</strong> sections below to setup your local environment for testing with our client applications.</p>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<ol>
<li>Install the system dependencies required for building NSS</li>
<li>Install gyp: <code>apt install gyp</code> (required for NSS)</li>
<li>Install ninja-build: <a href="https://github.com/ninja-build/ninja/wiki/Pre-built-Ninja-packages#package-managers">via package for distribution</a></li>
<li>Install python3: <a href="https://docs.python.org/3/using/unix.html">3.6 via python.org</a></li>
<li>Install zlib: <code>apt install zlib1g-dev</code></li>
<li>Install the system dependencies required for SQLcipher</li>
<li>Install tcl: <code>apt install tclsh</code> (required for SQLcipher)</li>
</ol>
<h4 id="macos"><a class="header" href="#macos">MacOS</a></h4>
<ol>
<li>Install Xcode: check the <a href="../.circleci/config">ci config</a> for the correct
version.</li>
<li>Install Xcode tools: <code>xcode-select --install</code></li>
<li>Install homebrew: <a href="https://brew.sh/">via homebrew</a> (its what we use for ci)</li>
<li>Install the system dependencies required for building NSS
<ol>
<li>Install ninja: <code>brew install ninja</code></li>
<li>Install gyp (via https://github.com/mogemimi/pomdog/wiki/How-to-Install-GYP)</li>
</ol>
</li>
<li>Install swift-protobuf: <code>brew install swift-protobuf</code></li>
</ol>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<p><em>Install windows build tools</em></p>
<blockquote>
<p>Why <a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux (WSL)</a>?</p>
<p>It's currently tricky to get some of these builds working on Windows, primarily due to our use of SQLcipher. By using WSL it is possible to get builds working, but still have them published to your &quot;native&quot; local maven cache so it's available for use by a &quot;native&quot; Android Studio.</p>
</blockquote>
<ol>
<li>Install <a href="https://docs.microsoft.com/en-us/windows/wsl/about">WSL</a> (recommended over native tooling)</li>
<li>Install unzip: <code>sudo apt install unzip</code></li>
<li>Install python3: <code>sudo apt install python3</code> <em>Note: must be python 3.6</em></li>
<li>Install system build tools: <code>sudo apt install build-essential</code></li>
<li>Install zlib: <code>sudo apt-get install zlib1g-dev</code></li>
<li>Install tcl: <code>sudo apt install tcl-dev</code></li>
</ol>
<hr />
<h2 id="building-for-fenix"><a class="header" href="#building-for-fenix">Building for Fenix</a></h2>
<p>The instructions here assume that you are building for Fenix in order test your changes in Fenix and want to take advantage of the
<a href="https://github.com/mozilla-mobile/fenix/#auto-publication-workflow-for-android-components-and-application-services">Fenix Auto-publication workflow for android-components and application-services</a></p>
<ol>
<li>Install Android SDK, JAVA, NDK and set required env vars
<ol>
<li>Clone the <a href="https://github.com/mozilla-mobile/fenix/">Fenix</a> repository (not in a-s)</li>
<li>Clone the <a href="https://github.com/mozilla-mobile/android-components/">android-components</a> repository (not in a-s)</li>
<li>Install [Java <strong>8</strong>] for your system</li>
<li>Set <code>JAVA_HOME</code> to point to the JDK 8 installation directory.</li>
<li>Download and install <a href="https://developer.android.com/studio/#downloads">Android Studio</a></li>
<li>Set <code>ANDROID_SDK_ROOT</code> and <code>ANDROID_HOME</code> to the Android Studio sdk location and add it to your rc file.</li>
<li>Configure the required versions of NDK
<code>Configure menu &gt; System Settings &gt; Android SDK &gt; SDK Tools &gt; NDK &gt; Show Package Details &gt; NDK (Side by side)</code>
<ul>
<li>21.3.6528147 (required by Fenix)</li>
<li>21.0.6113669 (required by a-s)</li>
</ul>
</li>
</ol>
</li>
<li>If you are on Windows using WSL - drop to the section below, Windows setup
for Android (WSL) before proceeding.</li>
<li>Check dependencies, environment variables and test
<ol>
<li>Run <code>./libs/verify-android-environment.sh</code></li>
<li>Follow instructions and rerun until it is successful.</li>
</ol>
</li>
</ol>
<h3 id="windows-setup-for-android-via-wsl"><a class="header" href="#windows-setup-for-android-via-wsl">Windows setup for Android (via WSL)</a></h3>
<p>Note: For non-Ubuntu linux versions, it may be necessary to execute <code>$ANDROID_HOME/tools/bin/sdkmanager &quot;build-tools;26.0.2&quot; &quot;platform-tools&quot; &quot;platforms;android-26&quot; &quot;tools&quot;</code>. See also <a href="https://gist.github.com/fdmnio/fd42caec2e5a7e93e12943376373b7d0">this gist</a> for additional info.</p>
<h4 id="configure-maven"><a class="header" href="#configure-maven">Configure Maven</a></h4>
<p>Configure maven to use the native windows maven repository - then, when doing ./gradlew install from WSL, it ends up in the Windows maven repo. This means we can do a number of things with Android Studio in &quot;native&quot; windows and have then work correctly with stuff we built in WSL.</p>
<ol>
<li>Install maven: <code>sudo apt install maven</code></li>
<li>Confirm existence of (or create) a <code>~/.m2</code> folder</li>
<li>In the <code>~/.m2</code> create a file called <code>settings.xml</code></li>
<li>Add the content below replacing <code>{username}</code> with your username:</li>
</ol>
<pre><code>    &lt;settings&gt;
      &lt;localRepository&gt;/mnt/c/Users/{username}/.m2/repository&lt;/localRepository&gt;
    &lt;/settings&gt;
</code></pre>
<hr />
<h2 id="building-for-firefox-ios"><a class="header" href="#building-for-firefox-ios">Building for Firefox iOS</a></h2>
<ol>
<li>Install Carthage: <code>brew install carthage</code></li>
<li>Install <a href="https://github.com/xcpretty/xcpretty#installation">xcpretty</a>: <code>gem install xcpretty</code></li>
<li>Run <code>./libs/verify-ios-environment.sh</code> to check your setup and environment
variables.</li>
<li>Make any corrections recommended by the script and re-run.</li>
<li>Follow the guide for <a href="https://github.com/mozilla/application-services/blob/main/docs/howtos/locally-published-components-in-ios.md#using-locally-published-components-in-firefox-for-ios">using local a-s builds in iOS</a></li>
</ol>
<blockquote>
<p>Note: The built Xcode project is located at <code>megazords/ios/MozillaAppServices.xcodeproj</code>.</p>
</blockquote>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/building.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="using-locally-published-components-in-fenix"><a class="header" href="#using-locally-published-components-in-fenix">Using locally-published components in Fenix</a></h1>
<p>It's often important to test work-in-progress changes to this repo against a real-world
consumer project. The most reliable method of performing such testing is to publish your
components to a local Maven repository, and adjust the consuming project to install them
from there.</p>
<p>With support from the upstream project, it's possible to do this in a single step using
our auto-publishing workflow.</p>
<h2 id="using-the-auto-publishing-workflow"><a class="header" href="#using-the-auto-publishing-workflow">Using the auto-publishing workflow</a></h2>
<p>Some consumers (notably <a href="https://github.com/mozilla-mobile/fenix/">Fenix</a>) have support for
automatically publishing and including a local development version of application-services
in their build. The workflow is:</p>
<ol>
<li>
<p>Check out the consuming project.</p>
</li>
<li>
<p>Edit (or create) the file <code>local.properties</code> <em>in the consuming project</em> and tell it where to
find your local checkout of application-services, by adding a line like:</p>
<p><code>autoPublish.application-services.dir=path/to/your/checkout/of/application-services</code></p>
</li>
<li>
<p>Build the consuming project following its usual build procedure, e.g. via <code>./gradlew assembleDebug</code> or <code>./gradlew test</code>.</p>
</li>
</ol>
<p>If all goes well, this should automatically build your checkout of application-servies, publish it
to a local maven repository, and configure the consuming project to install from there instead of
from our published releases.</p>
<h2 id="using-a-manual-workflow"><a class="header" href="#using-a-manual-workflow">Using a manual workflow</a></h2>
<p>Note: This is a bit tedious, and you should first try the auto-publishing workflow described
above. But if the auto-publishing workflow bitrots then it's important to know how to do it
by hand. Since most consuming apps get their copy of application-services via a dependency
on android-components, this procedure involves three separate repos:</p>
<ol>
<li>
<p>Inside the <code>application-services</code> repository root:</p>
<ol>
<li>
<p>In <a href="howtos/app-services-yaml"><code>.buildconfig-android.yml</code></a>, change
<code>libraryVersion</code> to end in <code>-TESTING$N</code> <sup><a href="howtos/locally-published-components-in-fenix.html#note1">1</a></sup>,
where <code>$N</code> is some number that you haven't used for this before.</p>
<p>Example: <code>libraryVersion: 0.27.0-TESTING3</code></p>
</li>
<li>
<p>Check your <code>local.properties</code> file, and add <code>rust.targets=x86</code> if you're
testing on the emulator, <code>rust.targets=arm</code> if you're testing on 32-bit
arm (arm64 for 64-bit arm, etc). This will make the build that's done in
the next step much faster.</p>
</li>
<li>
<p>Run <code>./gradlew publishToMavenLocal</code>. This may take between 5 and 10 minutes.</p>
</li>
</ol>
</li>
<li>
<p>Inside the <code>android-components</code> repository root:</p>
<ol>
<li>
<p>In <a href="howtos/android-components-yaml"><code>.buildconfig.yml</code></a>, change
<code>componentsVersion</code> to end in <code>-TESTING$N</code> <sup><a href="howtos/locally-published-components-in-fenix.html#note1">1</a></sup>,
where <code>$N</code> is some number that you haven't used for this before.</p>
<p>Example: <code>componentsVersion: 0.51.0-TESTING3</code></p>
</li>
<li>
<p>Inside <a href="howtos/android-components-deps"><code>buildSrc/src/main/java/Dependencies.kt</code></a>,
change <code>mozilla_appservices</code> to reference the <code>libraryVersion</code> you
published in step 1 part 1.</p>
<p>Example: <code>const val mozilla_appservices = &quot;0.27.0-TESTING3&quot;</code></p>
</li>
<li>
<p>Inside <a href="howtos/android-components-build-gradle"><code>build.gradle</code></a>, add
<code>mavenLocal()</code> inside <code>allprojects { repositories { &lt;here&gt; } }</code>.</p>
</li>
<li>
<p>Inside the android-components <code>local.properties</code> file, ensure
<code>autoPublish.application-services.dir</code> is <em>NOT</em> set.</p>
</li>
<li>
<p>Run <code>./gradlew publishToMavenLocal</code>.</p>
</li>
</ol>
</li>
<li>
<p>Inside the consuming project repository root:</p>
<ol>
<li>
<p>Inside <a href="howtos/fenix-build-gradle-1"><code>build.gradle</code></a>, add
<code>mavenLocal()</code> inside <code>allprojects { repositories { &lt;here&gt; } }</code>.</p>
</li>
<li>
<p>Ensure that <code>local.properties</code> does not contain any configuration to
related to auto-publishing the application-services repo.</p>
</li>
<li>
<p>Inside <a href="howtos/fenix-deps"><code>buildSrc/src/main/java/Dependencies.kt</code></a>, change the
version numbers for android-components and/or application-services to
match the new versions you defined above.</p>
<p>Example: <code>const val mozilla_android_components = &quot;0.51.0-TESTING3&quot;</code></p>
<p>Example: <code>const val mozilla_appservices = &quot;0.27.0-TESTING3&quot;</code></p>
</li>
</ol>
</li>
</ol>
<p>You should now be able to build and run the consuming application (assuming you could
do so before all this).</p>
<h3 id="caveats"><a class="header" href="#caveats">Caveats</a></h3>
<ol>
<li>This assumes you have followed the <a href="howtos/./setup-android-build-environment.html">android/rust build setup</a></li>
<li>Make sure you're fully up to date in all repos, unless you know you need to
not be.</li>
<li>This omits the steps if changes needed because, e.g. application-services
made a breaking change to an API used in android-components. These should be
understandable to fix, you usually should be able to find a PR with the fixes
somewhere in the android-component's list of pending PRs (or, failing that, a
description of what to do in the application-services changelog).</li>
<li>Ask in #sync if you get stuck.</li>
</ol>
<h2 id="adding-support-for-the-auto-publish-workflow"><a class="header" href="#adding-support-for-the-auto-publish-workflow">Adding support for the auto-publish workflow</a></h2>
<p>If you had to use the manual workflow above and found it incredibly tedious, you might like to
try adding support for the auto-publish workflow to the consuming project! The details will differ
depending on the specifics of the project's build setup, but at a high level you will need to:</p>
<ol>
<li>
<p>In your <a href="howtos/fenix-settings">settings.gradle</a>, locate (or add) the code for parsing the <code>local.properties</code> file,
and add support for loading a directory path from the property <code>autoPublish.application-services.dir</code>.</p>
<p>If this property is present, spawn a subprocess to run <code>./gradlew autoPublishForLocalDevelopment</code>
in the specified directory. This automates step (1) of the manual workflow above, publishing your
changes to application-services into a local maven repository under a unique version number.</p>
</li>
<li>
<p>In your <a href="howtos/%5Bfenix-build-gradle-1%5D">build.gradle</a>, if the <code>autoPublish.application-services.dir</code> property
is present, have each project apply the build script from <code>./build-scripts/substitute-local-appservices.gradle</code>
in the specified directory.</p>
<p>This automates steps (2) and (3) of the manual workflow above, using gradle's dependency substitution
capabilities to override the verion requirements for application-services components. It may be necessary
to experiment with the ordering of this relative to other build configuration steps, in order for the
dependency substitution to work correctly.</p>
<p>For a single-project build this would look something like:</p>
<pre><code class="language-groovy">if (gradle.hasProperty('localProperties.autoPublish.application-services.dir')) {
   ext.appServicesSrcDir = gradle.&quot;localProperties.autoPublish.application-services.dir&quot;
   apply from: &quot;${appServicesSrcDir}/build-scripts/substitute-local-appservices.gradle&quot;
}
</code></pre>
<p>For a multi-project build it should be applied to all subprojects, like:</p>
<pre><code class="language-groovy">subprojects {
   if (gradle.hasProperty('localProperties.autoPublish.application-services.dir')) {
      ext.appServicesSrcDir = gradle.&quot;localProperties.autoPublish.application-services.dir&quot;
      apply from: &quot;${rootProject.projectDir}/${appServicesSrcDir}/build-scripts/substitute-local-appservices.gradle&quot;
   }
}
</code></pre>
</li>
<li>
<p>Confirm that the setup is working, by adding <code>autoPublish.application-services.dir</code> to your
<code>local.properties</code> file and running <code>./gradlew dependencies</code> for the project.</p>
<p>You should be able to see gradle checking the build status of the various application-services
dependencies as part of its setup phase. When the command completes, it should print the resolved
versions of all dependencies, and you should see that application-services components have a version
number in the format <code>0.0.1-SNAPSHOT-{TIMESTAMP}</code>.</p>
</li>
</ol>
<hr />
<p><b id="note1">[1]</b>: It doesn't have to start with <code>-TESTING</code>, it only needs
to have the format <code>-someidentifier</code>. <code>-SNAPSHOT$N</code> is also very common to use,
however without the numeric suffix, this has specific meaning to gradle, so we
avoid it.  Additionally, while the <code>$N</code> we have used in our running example has
matched (e.g. all of the identifiers ended in <code>-TESTING3</code>, this is not required,
so long as you match everything up correctly at the end. This can be tricky, so
I always try to use the same number).</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/locally-published-components-in-fenix.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="using-locally-published-components-in-firefox-for-ios"><a class="header" href="#using-locally-published-components-in-firefox-for-ios">Using locally-published components in Firefox for iOS</a></h1>
<p>It's often important to test work-in-progress changes to this repo against a real-world
consumer project. Here are our current best-practices for approaching this on iOS:</p>
<ol>
<li>
<p>Make a local build of the application-services framework using <code>./build-carthage.sh</code>.</p>
</li>
<li>
<p>Checkout and <code>carthage bootstrap</code> the consuming app (for example using <a href="https://github.com/mozilla-mobile/firefox-ios#building-the-code">these instructions with Firefox for
iOS</a>).</p>
</li>
<li>
<p>In the consuming app, replace the application-services framework with a copy of your local build. For example:</p>
<pre><code>rm -rf Carthage/Build/iOS/MozillaAppServices.framework
rsync -ad path/to/application-services/Carthage/Build/iOS/MozillaAppServices.framework/ Carthage/Build/iOS/MozillaAppServices.framework/
</code></pre>
</li>
<li>
<p>Open the consuming app project in XCode and build it from there.</p>
</li>
</ol>
<p>After making changes to application-services code, you will need to re-run these steps in order to
copy the latest changes over into the consuming app.</p>
<p>Firefox for iOS also has a helper script that automates these steps:
<a href="https://github.com/mozilla-mobile/firefox-ios/blob/main/appservices_local_dev.sh"><code>appservices_local_dev.sh</code></a>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/locally-published-components-in-ios.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="building-and-using-a-locally-modified-version-of-jna"><a class="header" href="#building-and-using-a-locally-modified-version-of-jna">Building and using a locally-modified version of JNA</a></h1>
<p><a href="https://github.com/java-native-access/jna/">Java Native Access</a> is an important dependency
for the Application Services components on Android, as it provides the low-level interface
from the JVM into the natively-compiled Rust code.</p>
<p>If you need to work with a locally-modified version of JNA (e.g. to investigate an apparent
JNA bug) then you may find these notes helpful.</p>
<hr />
<p>The JNA docs do have an <a href="https://github.com/java-native-access/jna/blob/master/www/AndroidDevelopmentEnvironment.md">Android Development Environment guide</a>
that is a good starting point, but the instructions did not work for me and appear a little out of date.
Here are the steps that worked for me:</p>
<ul>
<li>
<p>Modify your environment to specify <code>$NDK_PLATFORM</code>, and to ensure the Android NDK tools
for each target platform are in your <code>$PATH</code>. On my Mac with Android Studio the
config was as follows:</p>
<pre><code>export NDK_ROOT=&quot;$HOME/Library/Android/sdk/ndk/21.3.6528147&quot;
export NDK_PLATFORM=&quot;$NDK_ROOT/platforms/android-21&quot;
export PATH=&quot;$PATH:$NDK_ROOT/toolchains/llvm/prebuilt/darwin-x86_64/bin&quot;
export PATH=&quot;$PATH:$NDK_ROOT/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin&quot;
export PATH=&quot;$PATH:$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin&quot;
export PATH=&quot;$PATH:$NDK_ROOT/toolchains/x86-4.9/prebuilt/darwin-x86_64/bin&quot;
export PATH=&quot;$PATH:$NDK_ROOT/toolchains/x86_64-4.9/prebuilt/darwin-x86_64/bin&quot;
</code></pre>
<p>You will probably need to tweak the paths and version numbers based on your operating system and
the details of how you installed the Android NDK.</p>
</li>
<li>
<p>Install the <code>ant</code> build tool (using <code>brew install ant</code> worked for me).</p>
</li>
<li>
<p>Checkout the <a href="https://github.com/java-native-access/jna">JNA source</a> from Github. Try doing a basic
build via <code>ant dist</code> and <code>ant test</code>. This won't build for Android but will test the rest of the tooling.</p>
</li>
<li>
<p>Adjust <code>./native/Makefile</code> for compatibility with your Android NSK install. Here's what I had to do for mine:</p>
<ul>
<li>Adjust the <code>$CC</code> variable to use clang instead of gcc: <code>CC=aarch64-linux-android21-clang</code>.</li>
<li>Adjust thd <code>$CCP</code> variable to use the version from your system: <code>CPP=cpp</code>.</li>
<li>Add <code>-landroid -llog</code> to the list of libraries to link against in <code>$LIBS</code>.</li>
</ul>
</li>
<li>
<p>Build the JNA native libraries for the target platforms of interest:</p>
<ul>
<li><code>ant -Dos.prefix=android-aarch64</code></li>
<li><code>ant -Dos.prefix=android-armv7</code></li>
<li><code>ant -Dos.prefix=android-x86</code></li>
<li><code>ant -Dos.prefix=android-x86-64</code></li>
</ul>
</li>
<li>
<p>Package the newly-built native libraries into a JAR/AAR using <code>ant dist</code>.
This should produce <code>./dist/jna.aar</code>.</p>
</li>
<li>
<p>Configure <code>build.gradle</code> for the consuming application to use the locally-built JNA artifact:</p>
<pre><code>// Tell gradle where to look for local artifacts.
repositories {
    flatDir {
        dirs &quot;/PATH/TO/YOUR/CHECKOUT/OF/jna/dist&quot;
    }
}

// Tell gradle to exclude the published version of JNA.
configurations {
    implementation {
        exclude group: &quot;net.java.dev.jna&quot;, module:&quot;jna&quot;
    }
}

// Take a direct dependency on the local JNA AAR.
dependencies {
    implementation name: &quot;jna&quot;, ext: &quot;aar&quot;
}
</code></pre>
</li>
<li>
<p>Rebuild and run your consuming application, and it should be using the locally-built JNA!</p>
</li>
</ul>
<p>If you're trying to debug some unexpected JNA behaviour (and if you favour old-school printf-style debugging)
then you can this code snippet to print to the Android log from the compiled native code:</p>
<pre><code>#ifdef __ANDROID__
#include &lt;android/log.h&gt;
#define HACKY_ANDROID_LOG(...) __android_log_print(ANDROID_LOG_VERBOSE, &quot;HACKY-DEBUGGING-FOR-ALL&quot;, __VA_ARGS__)
#else
#define HACKY_ANDROID_LOG(MSG)
#endif

HACKY_ANDROID_LOG(&quot;this will go to the android logcat output&quot;);
HACKY_ANDROID_LOG(&quot;it accepts printf-style format sequences, like this: %d&quot;, 42);
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/locally-building-jna.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="guide-to-testing-a-rust-component"><a class="header" href="#guide-to-testing-a-rust-component">Guide to Testing a Rust Component</a></h1>
<p>This document gives a high-level overview of how we test components in application-services.
It will be useful to you if you're adding a new component, or working on increasing the test
coverage of an existing component.</p>
<p>If you are only interested in running the existing test suite, please consult the
<a href="howtos/../contributing.html">contributor docs</a> and the <a href="howtos/../../automation/tests.py">tests.py</a> script.</p>
<h2 id="unit-and-functional-tests"><a class="header" href="#unit-and-functional-tests">Unit and Functional Tests</a></h2>
<h3 id="rust-code"><a class="header" href="#rust-code">Rust code</a></h3>
<p>Since the core implementation of our components lives in rust, so does the core of our testing strategy.</p>
<p>Each rust component should be accompanied by a suite of unittests, following the <a href="https://doc.rust-lang.org/book/ch11-00-testing.html">guidelines for writing
tests</a> from the <a href="https://doc.rust-lang.org/book/title-page.html">Rust
Book</a>.
Some additional tips:</p>
<ul>
<li>
<p>Where possible, it's better use use the Rust typesystem to make bugs impossible than to write
tests to assert that they don't occur in practice. But given that the ultimate consumers of our
code are not in Rust, that's sometimes not possible. The best idiomatic Rust API for a feature
is not necessarily the best API for consuming it over an FFI boundary!</p>
</li>
<li>
<p>Rust's builtin assertion macros are pretty spartan; we use the <a href="https://crates.io/crates/more_asserts">more_asserts</a>
for some additional helpers.</p>
</li>
<li>
<p>Rust's strict typing can make test mocks difficult. If there's something you need to mock out in tests,
make it a Trait and use the <a href="https://crates.io/crates/mockiato">mockiato</a> crate to mock it out.</p>
</li>
</ul>
<p>The Rust tests for a component should be runnable via <code>cargo test</code>.</p>
<h3 id="ffi-layer-code"><a class="header" href="#ffi-layer-code">FFI Layer code</a></h3>
<p>We currently do not test the FFI-layer Rust code for our components, since it's generally a very thin
wrapper around the underlying (and in theory well-tested!) Rust component code. If you find yourself
adding a particularly complex bit of code in an FFI-layer crate, add unittests in the same style as
for other Rust code.</p>
<p>(Editor's note: I remain hopeful that one day we'll autogenerate most of the FFI-layer code, and in
such a world we don't need to invest in tests for it.)</p>
<h3 id="kotlin-code"><a class="header" href="#kotlin-code">Kotlin code</a></h3>
<p>The Kotlin wrapper code for a component should have its own test suite, which should follow the general guidelines for
<a href="https://github.com/mozilla-mobile/shared-docs/blob/master/android/testing.md#jvm-testing">testing Android code in Mozilla projects</a>.
In practice that means we use
<a href="https://github.com/mozilla-mobile/shared-docs/blob/master/android/testing.md#junit-testing-framework">JUnit</a>
as the test framework and
<a href="https://github.com/mozilla-mobile/shared-docs/blob/master/android/testing.md#robolectric-android-api-shadows">Robolectric</a>
to provide implementations of Android-specific APIs.</p>
<p>The Kotlin tests for a component should be runnable via <code>./gradlew &lt;component&gt;:test</code>.</p>
<p>The tests at this layer are designed to ensure that the API binding code is working as intended,
and should not repeat tests for functionality that is already well tested at the Rust level.
But given that the Kotlin bindings involve a non-trivial amount of hand-written boilerplate code,
it's important to exercise that code throughly.</p>
<p>One complication with running Kotlin tests is that the code needs to run on your local development machine,
but the Kotlin code's native dependencies are typically compiled and packaged for Android devices. The
tests need to ensure that an appropriate version of JNA and of the compiled Rust code is available in
their library search path at runtime. Our <code>build.gradle</code> files contain a collection of hackery that ensures
this, which should be copied into any new components.</p>
<p>(Editor's note: I remain hopeful that one day we'll autogenerate most of the Kotlin binding code, and in
such a world we don't need to invest in tests for it.)</p>
<p>XXX TODO: talk about proguard? I don't really understand it...</p>
<p>XXX TODO: any additional tips here, such as mocking out storage etc?</p>
<h3 id="swift-code"><a class="header" href="#swift-code">Swift code</a></h3>
<p>The Swift wrapper code for a component should have its own test suite, using Apple's
<a href="https://developer.apple.com/documentation/xctest">XCode unittest framework</a>.</p>
<p>Due to the way that all rust components need to be compiled together into a single <a href="howtos/../design/megazords.html">&quot;megazord&quot;</a>
framework, this entire respository is a single XCode project. The Swift tests for each component
thus need to live under <code>megazords/ios/MozillaAppServicesTests/</code> rather than in the directory
for the corresponding component. (XXX TODO: is this true? it would be nice to find a way to avoid havining
them live separately because it makes them easy to overlook).</p>
<p>The tests at this layer are designed to ensure that the API binding code is working as intended,
and should not repeat tests for functionality that is already well tested at the Rust level.
But given that the Swift bindings involve a non-trivial amount of hand-written boilerplate code,
it's important to exercise that code throughly.</p>
<p>(Editor's note: I remain hopeful that one day we'll autogenerate most of the Swift binding code, and in
such a world we don't need to invest in tests for it.)</p>
<p>XXX TODO: any additional tips here, such as mocking out storage etc?</p>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration tests</a></h2>
<h3 id="end-to-end-sync-tests"><a class="header" href="#end-to-end-sync-tests">End-to-end Sync Tests</a></h3>
<p>The <a href="howtos/../../testing/sync-test"><code>testing/sync-test</code></a> directory contains a test harness for running sync-related
Rust components against a live Firefox Sync infrastructure, so that we can verifying the functionality
end-to-end.</p>
<p>Each component that implements a sync engine should have a corresponding suite of tests in this directory.</p>
<ul>
<li>XXX TODO: places doesn't.</li>
<li>XXX TODO: send-tab doesn't (not technically a sync engine, but still, it's related)</li>
<li>XXX TODO: sync-manager doesn't</li>
</ul>
<h3 id="android-components-test-suite"><a class="header" href="#android-components-test-suite">Android Components Test Suite</a></h3>
<p>It's important that changes in application-services are tested against upstream consumer code in the
<a href="https://github.com/mozilla-mobile/android-components/">android-components</a> repo. This is currently
a manual process involving:</p>
<ul>
<li>Configuring your local checkout of android-components to <a href="howtos/./working-with-reference-browser.html">use your local application-services
build</a>.</li>
<li>Running the android-components test suite via <code>./gradle test</code>.</li>
<li>Manually building and running the android-components sample apps to verify that they're still working.</li>
</ul>
<p>Ideally some or all of this would be automated and run in CI, but we have not yet invested in such automation.</p>
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<p>Lamentably, we do not measure or report on code test coverage.
See <a href="https://github.com/mozilla/application-services/issues/1745">this github issue</a> for some early explorations.</p>
<p>The rust ecosystem for code coverage is still maturing, with <a href="https://github.com/xd009642/tarpaulin">cargo-tarpaulin</a>
appearing to be a promising candidate.  However, such tools will only report code that is exercised by the rust
unittests, not code that is exercised by the Kotlin or Swift tests or the end-to-end integration test suite.</p>
<p>For code coverage to be useful to us, we need to either:</p>
<ul>
<li>Commit to ensuring high coverage via rust-level tests alone, or</li>
<li>Figure out how to measure it for code being driven by non-rust test suites.</li>
</ul>
<h2 id="ideas-for-improvement"><a class="header" href="#ideas-for-improvement">Ideas for Improvement</a></h2>
<ul>
<li>ASan, Memsan, and maybe other sanitizer checks, especially around the points where we cross FFI boundaries.</li>
<li>General-purpose fuzzing, such as via https://github.com/jakubadamw/arbitrary-model-tests</li>
<li>We could consider making a mocking backend for viaduct, which would also be mockable from Kotlin/Swift.</li>
<li>Add more end-to-end integration tests!</li>
<li>Live device tests, e.g. actual Fenixes running in an emulator and syncing to each other.</li>
<li>Run consumer integration tests in CI against main.</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/testing-a-rust-component.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="smoke-testing-application-services-against-end-user-apps"><a class="header" href="#smoke-testing-application-services-against-end-user-apps">Smoke testing Application Services against end-user apps</a></h1>
<p>This is a great way of finding integration bugs with application services.
It can be done manually using substitution scripts, but we also have scripts that will do all of these for you.</p>
<h2 id="firefox-ios"><a class="header" href="#firefox-ios">Firefox iOS</a></h2>
<p>The <code>automation/smoke-test-firefox-ios.py</code> script will clone (or use a local version) of Firefox iOS and
run tests against the current application-services worktree.<br />
Add the <code>-h</code> argument to discover all of the script's exciting options!</p>
<h2 id="android-components"><a class="header" href="#android-components">Android Components</a></h2>
<p>The <code>automation/smoke-test-android-components.py</code> script will clone (or use a local version) of
android-components and run a subset of its tests against the current application-services worktree.
It tries to only run tests that might be relevant to application-services functionality.</p>
<h2 id="fenix"><a class="header" href="#fenix">Fenix</a></h2>
<p>The <code>automation/smoke-test-fenix.py</code> script will clone (or use a local version) of Fenix and
run tests against the current application-services worktree.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/smoke-testing-app-services.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testing-faster-how-to-avoid-making-compile-times-worse-by-adding-tests"><a class="header" href="#testing-faster-how-to-avoid-making-compile-times-worse-by-adding-tests">Testing faster: How to avoid making compile times worse by adding tests</a></h1>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>We'd like to keep <code>cargo test</code>, <code>cargo build</code>, <code>cargo check</code>, ... reasonably
fast, and we'd <em>really</em> like to keep them fast if you pass <code>-p</code> for a specific
project. Unfortunately, there are a few ways this can become unexpectedly slow.
The easiest of these for us to combat at the moment is probably unfortunate
placement of dev-dependencies in our build graph.</p>
<p>If you perform a <code>cargo test -p foo</code>, all dev-dependencies of <code>foo</code> must be
compiled before <code>foo</code>'s tests can start. This includes dependencies only used
non-test targets, such as examples or benchmarks.</p>
<p>In an ideal world, cargo could run your tests as soon as it finished with the
dependencies it needs for those tests, instead of waiting for your benchmark
suite, or the arg-parser your examples use, or etc.</p>
<p>Unfortunately, all cargo knows is that these are <code>dev-dependencies</code>, and not
which targets actually use them. (Aside: Now that per-target feature selection
is stable we actually could fix this, however it would be extremely tedious, far
worse than the approach outlined in this document).</p>
<p>Additionally, unqualified invocations of cargo (that is, without <code>-p</code>) might
have an even worse time if we aren't careful. If I run, <code>cargo test</code>, cargo
knows <em>every</em> crate in the workspace needs to be built with all dev
dependencies, if <code>places</code> depends on <code>fxa-client</code>, all of <code>fxa-clients</code>
dev-dependencies must be compiled, ready, and linked in at least to the <code>lib</code>
target before we can even think about starting on <code>places</code>.</p>
<p>This should all sound somewhat obvious, and I guess it is. We have not been
careful about what shape the dependency graph ends up as when example code is
taken into consideration (as it is by cargo during certain builds), and as a
result, we have this problem. The problem is that this isn't really a problem we
want to fix: Example code can and should depend on several different components,
and use them together in interesting ways.</p>
<p>So, because we don't really want to change the things our examples do, or make
major architectural changes of the non-test code for something like this, we
need to do something.</p>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>To fix this, we manually insert &quot;cuts&quot; into the dependency graph to help cargo
out. That is, we pull some of these build targets (e.g. examples, benchmarks,
tests if they cause a substantial compile overhead) into their own dedicated
crates so that:</p>
<ol>
<li>They can be built in parallel with each other.</li>
<li>Crates depending on the component itself are not waiting on the
test/bench/example build in order for their test build to begin.</li>
<li>A potentially smaller set of our crates need to be rebuilt -- and a smaller
set of possible configurations exist meaning fewer items to add pressure to
caches.</li>
<li>...</li>
</ol>
<p>There's no firm rule for this, but the following guidelines seem easy to follow:</p>
<p>Basically, some rules of thumb for when / when not to do this:</p>
<ul>
<li>
<p>All rust examples should be put in <code>examples/*</code>.</p>
</li>
<li>
<p>All rust benchmarks should be put in <code>testing/separated/*</code>. See the section
below on how to set your benchmark up to avoid redundant compiles.</p>
</li>
<li>
<p>Rust tests which brings in heavyweight dependencies should be evaluated on an
ad-hoc basis. If you're concerned, measure how long compilation takes
with/without, and consider how many crates depend on the crate where the test
lives (e.g. a slow test in support/foo might be far worse than one in a leaf
crate), etc...</p>
</li>
</ul>
<h3 id="appendix-how-to-avoid-redundant-compiles-for-benchmarks-and-integration-tests"><a class="header" href="#appendix-how-to-avoid-redundant-compiles-for-benchmarks-and-integration-tests">Appendix: How to avoid redundant compiles for benchmarks and integration tests</a></h3>
<p>To be clear, this is way more important for benchmarks (which always compile as
release and have a costly link phase).</p>
<p>Anyway, say you have a directory structure like the following:</p>
<pre><code>mycrate
  src
     lib.rs
 | ...
  benches
     bench0.rs
 |    bench1.rs
     bench2.rs
  tests
     test0.rs
 |    test1.rs
     test2.rs
  ...
</code></pre>
<p>When you run your integration tests or benchmarks, each of <code>test0</code>, <code>test1</code>,
<code>test2</code> or <code>bench0</code>, <code>bench1</code>, <code>bench2</code> is compiled as it's own crate that runs
the tests in question and exits.</p>
<p>That means 3 benchmark executables are built on release settings, and 3
integration test executables.</p>
<p>If you've ever tried to add a piece of shared utility code into your integration
tests, only to have cargo (falsely) complain that it is dead code: this is why.
Even if <code>test0.rs</code> and <code>test2.rs</code> <em>both</em> use the utility function, unless
<em>every</em> test crate uses <em>every</em> shared utility, the crate that doesn't will
complain.</p>
<p>(Aside: This turns out to be an unintentional secondary benefit of this approach
-- easier shared code among tests, without having to put a
<code>#![allow(dead_code)]</code> in your utils.rs. We haven't hit that very much here,
since we tend to stick to unit tests, but it came up in mentat several times,
and is a frequent complaint people have)</p>
<p>Anyway, the solution here is simple: Create a new crate. If you were working in
<code>components/mycrate</code> and you want to add some integration tests or benchmarks,
you should do <code>cargo new --lib testing/separated/mycrate-test</code> (or
<code>.../mycrate-bench</code>).</p>
<p>Delete <code>.../mycrate-test/src/lib.rs</code>. Yep, really, we're making a crate that
only has integration tests/benchmarks (See the &quot;FAQ0&quot; section at the bottom of
the file if you're getting incredulous).</p>
<p>Now, add a <code>src/tests.rs</code> or a <code>src/benches.rs</code>. This file should contain <code>mod foo;</code> declarations for each submodule containing tests/benchmarks, if any.</p>
<p>For benches, this is also where you set up the benchmark harness (refer to
benchmark library docs for how).</p>
<p>Now, for a test, add: into your Cargo.toml</p>
<pre><code class="language-toml">[[test]]
name = &quot;mycrate-test&quot;
path = &quot;src/tests.rs&quot;
</code></pre>
<p>and for a benchmark, add:</p>
<pre><code class="language-toml">[[test]]
name = &quot;mycrate-benches&quot;
path = &quot;src/benches.rs&quot;
harness = false
</code></pre>
<p>Because we aren't using <code>src/lib.rs</code>, this is what declares which file is the
root of the test/benchmark crate. Because there's only one target (unlike with
<code>tests/*</code> / <code>benches/*</code> under default settings), this will compile more quickly.</p>
<p>Additionally, <code>src/tests.rs</code> and <code>src/benches.rs</code> will behave like a normal
crate, the only difference being that they don't produce a lib, and that they're
triggered by <code>cargo test</code>/<code>cargo run</code> respectively.</p>
<h3 id="faq0-why-put-testsbenches-in-src-instead-of-disabling-autotestsautobenches"><a class="header" href="#faq0-why-put-testsbenches-in-src-instead-of-disabling-autotestsautobenches">FAQ0: Why put tests/benches in <code>src/*</code> instead of disabling <code>autotests</code>/<code>autobenches</code></a></h3>
<p>Instead of putting tests/benchmarks inside <code>src</code>, we could just delete the <code>src</code>
dir outright, and place everything in <code>tests</code>/<code>benches</code>.</p>
<p>Then, to get the same one-rebuild-per-file behavior that we'll get in <code>src</code>, we
need to add <code>autotests = false</code> or <code>autobenches = false</code> to our Cargo.toml,
adding a root <code>tests/tests.rs</code> (or <code>benches/benches.rs</code>) containing <code>mod</code> decls
for all submodules, and finally by referencing that &quot;root&quot; in the Cargo.toml
<code>[[tests]]</code> / <code>[[benches]]</code> list, exactly the same way we did for using <code>src/*</code>.</p>
<p>This would work, and on the surface, using <code>tests/*.rs</code> and <code>benches/*.rs</code> seems
more consistent, so it seems weird to use <code>src/*.rs</code> for these files.</p>
<p>My reasoning is as follows: Almost universally, <code>tests/*.rs</code>, <code>examples/*.rs, </code>benches/*.rs`, etc. are automatic. If you add a test into the tests folder, it
will run without anything else.</p>
<p>If we're going to set up one-build-per-{test,bench}suite as I described, this
fundamentally cannot be true. In this paradigm, if you add a test file named
<code>blah.rs</code>, you must add a <code>mod blah</code> it to the parent module.</p>
<p>It seems both confusing and error-prone to use <code>tests/*</code>, but have it behave
that way, however this is absolutely the normal behavior for files in <code>src/*.rs</code>
-- When you add a file, you then need to add it to it's parent module, and this
is something Rust programmers are pretty used to.</p>
<p>(In fact, we even replicated this behavior (for no reason) in the places
integration tests, and added the <code>mod</code> declarations to a &quot;controlling&quot; parent
module -- It seems weird to be in an environment where this <em>isn't</em> required)</p>
<p>So, that's why. This way, we make it <em>way</em> less likely that you add a test file
to some directory, and have it get ignored because you didn't realize that in
this one folder, you need to add a <code>mod mytest</code> into a neighboring tests.rs.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/design/test-faster.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dependency-management-guidelines"><a class="header" href="#dependency-management-guidelines">Dependency Management Guidelines</a></h1>
<p>This repo uses third-party code from a variety of sources, so we need to be mindful
of how these dependencies will affect our consumers.  Considerations include:</p>
<ul>
<li>General code quality.</li>
<li><a href="https://www.mozilla.org/en-US/MPL/license-policy/#Licenses_Compatible_with_the_MPL">Licensing compatibility</a>.</li>
<li>Handling of security vulnerabilities.</li>
<li>The potential for <a href="https://medium.com/intrinsic/compromised-npm-package-event-stream-d47d08605502">supply-chain compromise</a>.</li>
</ul>
<p>We're still evolving our policies in this area, but these are the
guidelines we've developed so far.</p>
<h2 id="rust-code-1"><a class="header" href="#rust-code-1">Rust Code</a></h2>
<p>Unlike <a href="https://firefox-source-docs.mozilla.org/build/buildsystem/rust.html">Firefox</a>,
we do not vendor third-party source code directly into the repo.  Instead we rely on
<code>Cargo.lock</code> and its hash validation to ensure that each build uses an identical copy
of all third-party crates.  These are the measures we use for ongoing maintence of our
existing dependencies:</p>
<ul>
<li>Check <code>Cargo.lock</code> into the repository.</li>
<li>Generate built artifacts using the <code>--locked</code> flag to <code>cargo build</code>, as an additional
assurance that the existing <code>Cargo.lock</code> will be respected.
<ul>
<li>TODO: how to actually make this happen via rust-android-gradle plugin?</li>
</ul>
</li>
<li>Regularly run <a href="https://github.com/RustSec/cargo-audit">cargo-audit</a> in CI to alert us to
security problems in our dependencies.
<ul>
<li>It runs on every PR, and once per hour as a scheduled job with failures reported to slack.</li>
</ul>
</li>
<li>Use <a href="../tools/dependency_summary.py">a home-grown tool</a> to generate a summary of dependency licenses
and to check them for compatibility with MPL-2.0.
<ul>
<li>Check these summaries into the repository and have CI alert on unexpected changes,
to guard against pulling in new versions of a dependency under a different license.</li>
</ul>
</li>
</ul>
<p>Adding a new dependency, whether we like it or not, is a big deal - that dependency and everything
it brings with it will become part of Firefox-branded products that we ship to end users.
We try to balance this responsibility against the many benefits of using existing code, as follows:</p>
<ul>
<li>In general, be conservative in adding new third-party dependencies.
<ul>
<li>For trivial functionality, consider just writing it yourself.
Remember the cautionary tale of <a href="https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/">left-pad</a>.</li>
<li>Check if we already have a crate in our dependency tree that can provide the needed functionality.</li>
</ul>
</li>
<li>Prefer crates that have a a high level of due-dilligence already applied, such as:
<ul>
<li>Crates that are <a href="https://dxr.mozilla.org/mozilla-central/source/third_party/rust">already vendored into Firefox</a>.</li>
<li>Crates from <a href="https://github.com/rust-lang-nursery">rust-lang-nursery</a>.</li>
<li>Crates that appear to be widely used in the rust community.</li>
</ul>
</li>
<li>Check that it is clearly licensed and is <a href="https://www.mozilla.org/en-US/MPL/license-policy/#Licenses_Compatible_with_the_MPL">MPL-2.0 compatible</a>.</li>
<li>Take the time to investigate the crate's source and ensure it is suitably high-quality.
<ul>
<li>Be especially wary of uses of <code>unsafe</code>, or of code that is unusually resource-intensive to build.</li>
<li>Dev dependencies do not require as much scrutiny as dependencies that will ship in consuming applications,
but should still be given some thought.
<ul>
<li>There is still the potential for supply-chain compromise with dev dependencies!</li>
</ul>
</li>
</ul>
</li>
<li>As part of the PR that introduces the new dependency:
<ul>
<li>Regenerate dependency summary files using the <a href="../tools/regenerate_dependency_summaries.sh">regenerate_dependency_summaries.sh</a>.</li>
<li>Explicitly describe your consideration of the above points.</li>
</ul>
</li>
</ul>
<p>Updating to new versions of existing dependencies is a normal part of software development
and is not accompanied by any particular ceremony.</p>
<h2 id="androidkotlin-code"><a class="header" href="#androidkotlin-code">Android/Kotlin Code</a></h2>
<p>We currently depend only on the following Kotlin dependencies:</p>
<ul>
<li><a href="https://github.com/java-native-access/jna">JNA</a></li>
<li><a href="https://github.com/google/protobuf-gradle-plugin">protobuf-gradle-plugin</a></li>
</ul>
<p>We currently depend on the following <strong>developer</strong> dependencies in the Kotlin codebase,
but they do not get included in built distribution files:</p>
<ul>
<li>detekt</li>
<li>ktlint</li>
</ul>
<p>No additional Kotlin dependencies should be added to the project unless absolutely necessary.</p>
<h2 id="iosswift-code"><a class="header" href="#iosswift-code">iOS/Swift Code</a></h2>
<p>We currently depend only on the <a href="https://github.com/mozilla/application-services/blob/main/Cartfile">following dependencies</a>:</p>
<ul>
<li><a href="https://github.com/apple/swift-protobuf">swift-protobuf</a></li>
<li><a href="https://github.com/jrendel/SwiftKeychainWrapper/">SwiftKeychainWrapper</a></li>
</ul>
<p>No additional Swift dependencies should be added to the project unless absolutely necessary.</p>
<h2 id="other-code"><a class="header" href="#other-code">Other Code</a></h2>
<p>We currently depend on local builds of the following system dependencies:</p>
<ul>
<li><a href="https://hg.mozilla.org/projects/nss">NSS</a> and <a href="https://hg.mozilla.org/projects/nspr">NSPR</a></li>
<li><a href="https://github.com/sqlcipher/sqlcipher">SQLCipher</a></li>
<li><a href="https://github.com/protocolbuffers/protobuf">Protobuf</a></li>
</ul>
<p>No additional system dependencies should be added to the project unless absolutely necessary.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/dependency-management.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-new-component-to-application-services"><a class="header" href="#adding-a-new-component-to-application-services">Adding a new component to Application Services</a></h1>
<p>Each component in the Application Services repo has three parts (the Rust code,
the Kotlin wrapper, and the Swift wrapper) so there are quite a few moving
parts involved in adding a new component. This is a rapid-fire list of all
the things you'll need to do if adding a new component from scratch.</p>
<h2 id="the-rust-code"><a class="header" href="#the-rust-code">The Rust Code</a></h2>
<p>Your component should live under <code>./components</code> in this repo.
Use <code>cargo new --lib ./components/&lt;your_crate_name&gt;</code>to create a new library crate,
and please try to avoid using hyphens in the crate name.</p>
<p>See the <a href="howtos/./building-a-rust-component.html">Guide to Building a Rust Component</a> for general
advice on designing and structuring the actual Rust code, and follow the
<a href="howtos/../dependency-management.html">Dependency Management Guidelines</a> if your crate
introduces any new dependencies.</p>
<p>Use <a href="https://mozilla.github.io/uniffi-rs/">UniFFI</a> to define how your crate's
API will get exposed to foreign-language bindings. By convention, put the interface
definition file at <code>./components/&lt;your_crate_name&gt;/&lt;your_crate_name&gt;.udl</code>. Use
the <code>builtin-bindgen</code> feature of UniFFI to simplify the build process, by
putting this in your <code>Cargo.toml</code>:</p>
<pre><code>[build-dependencies]
uniffi_build = { version = &quot;&lt;latest version here&gt;&quot;, features=[&quot;builtin-bindgen&quot;] }
</code></pre>
<p>Include your new crate in the application-services workspace, by adding
it to the <code>members</code> and <code>default-members</code> lists in the <code>Cargo.toml</code> at
the root of the repository.</p>
<p>In order to be published to consumers, your crate must be included in the
<a href="howtos/../design/megazords.html">&quot;megazord&quot;</a> crate for each target platform:</p>
<ul>
<li>For Android, add it as a dependency in <code>./megazords/full/Cargo.toml</code> and
add a <code>pub use &lt;your_crate_name&gt;</code> to <code>./megazords/full/src/lib.rs</code>.</li>
<li>For iOS, add it as a dependency in <code>./megazords/ios/rust/Cargo.toml</code> and
add a <code>pub use &lt;your_crate_name&gt;</code> to <code>./megazords/ios/rust/src/lib.rs</code>.</li>
</ul>
<p>Run <code>cargo check -p &lt;your_crate_name&gt;</code> in the repository root to confirm that
things are configured properly. This will also have the side-effect of updating
<code>Cargo.lock</code> to contain your new crate and its dependencies.</p>
<h2 id="the-kotlin-bindings"><a class="header" href="#the-kotlin-bindings">The Kotlin Bindings</a></h2>
<p>Make a <code>./components/&lt;your_crate_name&gt;/android</code> subdirectory to contain
Kotlin- and Android-specific code. This directory will contain a gradle
project for building your Kotlin bindings.</p>
<p>Copy the <code>build.gradle</code> file from <code>./components/crashtest/android/</code> into
your own component's directory, and edit it to replace the references to
<code>crashtest.udl</code> with your own component's <code>.udl</code> file.</p>
<p>Create a file <code>./components/&lt;your_crate_name&gt;/uniffi.toml</code> with the
following contents:</p>
<pre><code>[bindings.kotlin]
package_name = &quot;mozilla.appservices.&lt;your_crate_name&gt;&quot;
cdylib_name = &quot;megazord&quot;
</code></pre>
<p>Create a file <code>./components/&lt;your_crate_name&gt;/android/src/main/AndroidManifest.xml</code>
with the following contents:</p>
<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;org.mozilla.appservices.&lt;your_crate_name&gt;&quot; /&gt;
</code></pre>
<p>In the root of the repository, edit <code>.buildconfig-android.yml</code>to add
your component's metadata. This will cause it to be included in the
gradle workspace and in our build and publish pipeline. Check whether
it builds correctly by running:</p>
<ul>
<li><code>./gradlew &lt;your_crate_name&gt;:assembleDebug</code></li>
</ul>
<p>You can include hand-written Kotlin code alongside the automatically
generated bindings, by placing `.kt`` files in a directory named:</p>
<ul>
<li><code>./android/src/test/java/mozilla/appservices/&lt;your_crate_name&gt;/</code></li>
</ul>
<p>You can write Kotlin-level tests that consume your component's API,
by placing `.kt`` files in a directory named:</p>
<ul>
<li><code>./android/src/test/java/mozilla/appservices/&lt;your_crate_name&gt;/</code>.</li>
</ul>
<p>So you would end up with a directory structure something like this:</p>
<ul>
<li><code>components/&lt;your_crate_name&gt;/</code>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>uniffi.toml</code></li>
<li><code>src/</code>
<ul>
<li>Rust code here.</li>
</ul>
</li>
<li><code>android/</code>
<ul>
<li><code>build.gradle</code></li>
<li><code>src/</code>
<ul>
<li><code>main/</code>
<ul>
<li><code>AndroidManifest.xml</code></li>
<li><code>java/mozilla/appservices/&lt;your_crate_name&gt;/</code>
<ul>
<li>Hand-written Kotlin code here.</li>
</ul>
</li>
</ul>
</li>
<li><code>test/java/mozilla/appservices/&lt;your_crate_name&gt;/</code>
<ul>
<li>Kotlin test-cases here.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Run your component's Kotlin tests with <code>./gradlew &lt;your_crate_name&gt;:test</code>
to confirm that this is all working correctly.</p>
<h2 id="the-swift-bindings"><a class="header" href="#the-swift-bindings">The Swift Bindings</a></h2>
<p>Make a <code>./components/&lt;your_crate_name&gt;/ios</code> subdirectory to contain
Swift- and iOS-specific code. The UniFFI-generated swift bindings will
be written to a subdirectory named <code>Generated</code>.</p>
<p>You can include hand-written Swift code alongside the automatically
generated bindings, by placing <code>.swift</code> files in a directory named:
<code>./ios/&lt;your_crate_name&gt;/</code>.</p>
<p>So you would end up with a directory structure something like this:</p>
<ul>
<li><code>components/&lt;your_crate_name&gt;/</code>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>uniffi.toml</code></li>
<li><code>src/</code>
<ul>
<li>Rust code here.</li>
</ul>
</li>
<li><code>ios/</code>
<ul>
<li><code>&lt;your_crate_name&gt;/</code>
<ul>
<li>Hand-written Swift code here.</li>
</ul>
</li>
<li><code>Generated/</code>
<ul>
<li>Generated Swift code will be written into this directory.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Edit <code>megazords/ios/MozillaAppServices.h</code> and add an import line for your component,
like:</p>
<pre><code>#import &quot;uniffi_&lt;your_crate_name&gt;_Bridging-Header.h&quot;
</code></pre>
<p>You will then need to add your component into the iOS <a href="howtos/../design/megazords.html">&quot;megazord&quot;</a>
XCode project, which can only really by done using the XCode application,
which can only really be done if you're on a Mac.</p>
<p>Open <code>megazords/ios/MozillaAppServices.xcodeproj</code> in XCode.</p>
<p>In the Project navigator, add a new Group for your new component, pointing to
the <code>./ios/</code> directory you created above. Add the following entries to the Group:</p>
<ul>
<li>The <code>.udl</code> file for you component, from <code>../src/&lt;your_crate_name&gt;.udl</code>.</li>
<li>Any hand-written <code>.swift </code>files for your component</li>
<li>A sub-group named &quot;Generated&quot;, pointing to the <code>./Generated/</code> subdirectory, and
containing entries for the files generated by UniFFI:
<ul>
<li><code>&lt;your_crate_name&gt;.swift</code></li>
<li><code>uniffi_&lt;your_crate_name&gt;-Bridging-Header.h</code></li>
</ul>
</li>
</ul>
<p>The result should look something like this:</p>
<p><img src="howtos/./img/xcode_add_component_1.png" alt="Screenshot of XCode Project Navigator" /></p>
<p>Click on the top-level &quot;MozillaAppServices&quot; project in the navigator,
then go to &quot;Build Phases&quot; and add <code>&lt;your_crate_name&gt;.udl</code> to the list
of &quot;Compile Sources&quot;. This will trigger an XCode Build Rule that generates
the Swift bindings automatically. Also include any hand-written <code>.swift</code> files
in this list.</p>
<p>The result should look something like this:</p>
<p><img src="howtos/./img/xcode_add_component_2.png" alt="Screenshot of XCode Compile Sources list" /></p>
<p>In the same &quot;Build Phases&quot; screen, under the &quot;Headers&quot; section, add <code>uniffi_&lt;your_crate_name&gt;-Bridging-Header.h</code> to the list of Public headers.
The result should look something like this:</p>
<p><img src="howtos/./img/xcode_add_component_3.png" alt="Screenshot of XCode Headers list" /></p>
<p>Build the project in XCode to check whether that all worked correctly.</p>
<p>To add Swift tests for your component API, create them in a file under
<code>megazords/ios/MozillaAppServicesTests/</code>. Use this syntax to import
your component's bindings from the compiled megazord:</p>
<pre><code>@testable import MozillaAppServices
</code></pre>
<p>In XCode, navigate to the <code>MozillaAppServicesTests</code> Group and add your
new test file as an entry. Select the corresponding target, click on
&quot;Build Phases&quot;, and add your test file to the list of &quot;Compile Sources&quot;.
The result should look something like this:</p>
<p><img src="howtos/./img/xcode_add_component_4.png" alt="Screenshot of XCode Test Setup" /></p>
<p>Use the XCode Test Navigator to run your tests and check whether
they're passing.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/adding-a-new-component.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="guide-to-building-a-syncable-rust-component"><a class="header" href="#guide-to-building-a-syncable-rust-component">Guide to Building a Syncable Rust Component</a></h1>
<p>This is a guide to creating a new Syncable Rust Component like many of the
components in this repo. If you are looking for information how to build (ie,
compile, etc) the existing components, you are looking for
<a href="https://github.com/mozilla/application-services/blob/main/docs/building.md">our build documentation</a></p>
<p>Welcome!</p>
<p>It's great that you want to build a Rust Component - this guide should help
get you started. It documents some nomenclature, best-practices and other
tips and tricks to get you started.</p>
<p>This document is just for general guidance - every component will be different
and we are still learning how to make these components. Please update this
document with these learnings.</p>
<p>To repeat with emphasis - <strong>please consider this a living document</strong>.</p>
<h1 id="general-design-and-structure-of-the-component"><a class="header" href="#general-design-and-structure-of-the-component">General design and structure of the component</a></h1>
<p>We think components should be structured as described here.</p>
<h2 id="we-build-libraries-not-frameworks"><a class="header" href="#we-build-libraries-not-frameworks">We build libraries, not frameworks</a></h2>
<p>Think of building a &quot;library&quot;, not a &quot;framework&quot; - the application should be in
control and calling functions exposed by your component, not providing functions
for your component to call.</p>
<h2 id="the-store-is-the-entry-point"><a class="header" href="#the-store-is-the-entry-point">The &quot;store&quot; is the &quot;entry-point&quot;</a></h2>
<p>[Note that some of the older components use the term &quot;store&quot; differently; we
should rename them! In Places, it's called an &quot;API&quot;; in Logins an &quot;engine&quot;. See
<code>webext-storage</code> for a more recent component that uses the term &quot;Store&quot; as we
think it should be used.]</p>
<p>The &quot;Store&quot; is the entry-point for the consuming application - it provides the
core functionality exposed by the component and manages your databases and other
singletons. The responsibilities of this will include things like creating the
DB if it doesn't exist, doing schema upgrades etc.</p>
<p>The functionality exposed by the &quot;Store&quot; will depend on the complexity of the
API being exposed. For example, for <code>webext-storage</code>, where there are only a
handful of simple public functions, it just directly exposes all the
functionalty of the component. However, for Places, which has a much more
complex API, the (logical) Store instead supplies &quot;Connection&quot; instances which
expose the actual functionality.</p>
<h2 id="using-sqlite"><a class="header" href="#using-sqlite">Using sqlite</a></h2>
<p>We prefer sqlite instead of (say) JSON files or RKV.</p>
<p>Always put sqlite into WAL mode, then have exactly 1 writer connection and as
many reader connections you need - which will depend on your use-case - for
example, <code>webext_storage</code> has 1 reader, while <code>places</code> has many.</p>
<p>(Note that places has 2 writers (one for sync, one for the api), but we
believe this was a mistake and should have been able to make things work
better with exactly 1 shared between sync and the api)</p>
<p>We typically have a &quot;DB&quot; abstraction which manages the database itself - the
logic for handling schema upgrades etc and enforcing the &quot;only 1 writer&quot; rule
is done by this.</p>
<p>However, this is just a convenience - the DB abstrations aren't really passed
around - we just pass raw connections (or transactions) around. For example, if
there's a utility function that reads from the DB, it will just have a Rusqlite
connection passed. (Again, older components don't really do this well, but
<code>webext-storage</code> does)</p>
<p>We try and leverage rust to ensure transactions are enforced at the correct
boundaries - for example, functions which write data but which must be done as
part of a transaction will accept a Rusqlite <code>Transaction</code> reference as the
param, whereas something that only reads the Db will accept a Rusqlite
<code>Connection</code> - note that because <code>Transaction</code> supports
<code>Deref&lt;Target = Connection&gt;</code>, you can pass a <code>&amp;Transaction</code> wherever a
<code>&amp;Connection</code> is needed - but not vice-versa.</p>
<h3 id="meta-data"><a class="header" href="#meta-data">Meta-data</a></h3>
<p>You are likely to have a table just for key/value metadata, and this table will
be used by sync (and possibly other parts of the component) to track the
sync IDs, lastModified timestamps etc.</p>
<h3 id="schema-management"><a class="header" href="#schema-management">Schema management</a></h3>
<p>The schemas are stored in the tree in .sql files and pulled into the source at
build time via <code>include_str!</code>. Depending on the complexity of your component,
there may be a need for different Connections to have different Sql (for
example, it may be that only your 'write' connection requires the sql to define
triggers or temp tables, so these might be in their own file.)</p>
<p>Because requirements evolve, there will be a need to support schema upgrades.
This is done by way of sqlite's <code>PRAGMA user_version</code> - which can be thought of
as simple metadata for the database itself. In short, immediately after opening
the database for the first time, we check this version and if it's less than
expected we perform the schema upgrades necessary, then re-write the version
to the new version.</p>
<p>This is easier to read than explain, so read the <code>upgrade()</code> function in
<a href="https://github.com/mozilla/application-services/blob/main/components/places/src/db/schema.rs">the Places schema code</a></p>
<p>You will need to be a big careful here because schema upgrades are going to
block the calling application immediately after they upgrade to a new version,
so if your schema change requires a table scan of a massive table, you are going
to have a bad time. Apart from that though, you are largely free to do whatever
sqlite lets you do!</p>
<p>Note that most of our components have very similar schema and database
management code - these are screaming out to be refactored so common logic can
be shared. Please be brave and have a go at this!</p>
<h3 id="triggers"><a class="header" href="#triggers">Triggers</a></h3>
<p>We tend to like triggers for encompasing application logic - for example, if
updating one row means a row in a different table should be updated based on
that data, we'd tend to prefer an, eg,  <code>AFTER UPDATE</code> trigger than having our
code manually implement the logic.</p>
<p>However, you should take care here, because functionality based on triggers is
difficult to debug (eg, logging in a trigger is difficult) and the functionality
can be difficult to locate (eg, users unfamiliar with the component may wonder
why they can't find certain functionity in the rust code and may not consider
looking in the sqlite triggers)</p>
<p>You should also be careful when creating triggers on persistent main tables.
For example, bumping the change counter isn't a good use for a trigger,
because it'll run for all changes on the tableincluding those made by Sync.
This means Sync will end up tracking its own changes, and getting into infinite
syncing loops. Triggers on temporary tables, or ones that are used for
bookkeeping where the caller doesn't matter, like bumping the foreign
reference count for a URL, are generally okay.</p>
<h2 id="general-structure-of-the-rust-code"><a class="header" href="#general-structure-of-the-rust-code">General structure of the rust code</a></h2>
<p>We prefer flatter module hierarchies where possible. For example, in <code>Places</code>
we ended up with <code>sync_history</code> and <code>sync_bookmarks</code> sub-modules rather than
a <code>sync</code> submodule itself with <code>history</code> and <code>bookmarks</code>.</p>
<p>Note that the raw connections are never exposed to consumers - for example, they
will tend to be stored as private fields in, eg, a Mutex.</p>
<h1 id="syncing"><a class="header" href="#syncing">Syncing</a></h1>
<p>The traits you need to implement to sync aren't directly covered here.</p>
<p>All meta-data related to sync must be stored in the same database as the
data itself - often in a <code>meta</code> table.</p>
<p>All logic for knowing which records need to be sync must be part of the
application logic, and will often be implemented using <code>triggers</code>. It's quite
common for components to use a &quot;change counter&quot; strategy, which can be
summaried as:</p>
<ul>
<li>
<p>Every table which defines the &quot;top level&quot; items being synced will have a
column called something like 'sync_change_counter' - the app will probably
track this counter manually instead of using a trigger, because sync itself
will need different behaviour when it updates the records.</p>
</li>
<li>
<p>At sync time, items with a non-zero change counter are candidates for syncing.</p>
</li>
<li>
<p>As the sync starts, for each item, the current value of the change counter is
remembered. At the end of the sync, the counter is decremented by this value.
Thus, items which were changed between the time the sync started and completed
will be left with a non-zero change counter at the end of the sync.</p>
</li>
</ul>
<h2 id="syncing-faqs"><a class="header" href="#syncing-faqs">Syncing FAQs</a></h2>
<p>This section is stolen from <a href="https://docs.google.com/document/d/1s9ld2F4e83eQ944kN6QXXTRlqrX74w2AJS6W2fDyAJ8">this document</a></p>
<h3 id="whats-the-global-sync-id-and-the-collection-sync-id"><a class="header" href="#whats-the-global-sync-id-and-the-collection-sync-id">Whats the global sync ID and the collection sync ID?</a></h3>
<p>Both guids, both used to identify when the data in the server has changed
radically underneath us (eg, when looking at lastModified is no longer a sane
thing to do.)</p>
<p>The &quot;global sync ID&quot; changing means that every collection needs to be assumed as
having changed radically, whereas just the &quot;collection sync ID&quot; changing means
just that one collection.</p>
<p>These global IDs are most likely to change on a node reassignment (which should
be rare now with durable storage), a password reset, etc. An example of when the
collection ID will change is a &quot;bookmarks restore&quot; - handling an old version of
a database re-appearing is why we store these IDs in the database itself.</p>
<h3 id="whats-get_sync_assoc-why-is-it-important-what-is-storesyncassociation"><a class="header" href="#whats-get_sync_assoc-why-is-it-important-what-is-storesyncassociation">Whats <code>get_sync_assoc</code>, why is it important? What is <code>StoreSyncAssociation</code>?</a></h3>
<p>They are all used to track the guids above. Its vitally important we know when
these guids change.</p>
<p>StoreSyncAssociation is a simple enum which reflects the state a sync engine
can be in - either <code>Disconnected</code> (ie, we have no idea what the GUIDs are) or
<code>Connected</code> where we know what we think the IDs are (but the server may or may
not match with this)</p>
<p>These GUIDs will typically be stored in the DB in the metadata table.</p>
<h3 id="what-is-apply_incoming-versus-sync_finished"><a class="header" href="#what-is-apply_incoming-versus-sync_finished">what is <code>apply_incoming</code> versus <code>sync_finished</code></a></h3>
<p><code>apply_incoming</code> is where any records incoming from the server (ie, possibly
all records on the server if this is a first-sync, records with a timestamp
later than our last sync otherwise) are processed.</p>
<p><code>sync_finished</code> is where we've done all the sync work other than uploading new
changes to the server.</p>
<h3 id="whats-the-diff-between-reset-and-wipe"><a class="header" href="#whats-the-diff-between-reset-and-wipe">What's the diff between reset and wipe?</a></h3>
<ul>
<li>Reset means I dont know whats on the server - I need to reconcile everything there with everything I have. IOW, a first sync</li>
<li>Wipe means literally wipe all server data</li>
</ul>
<h1 id="exposing-to-consumers"><a class="header" href="#exposing-to-consumers">Exposing to consumers</a></h1>
<p>You will need an FFI or some other way of exposing stuff to your consumers.</p>
<p>We are exploring a tool called <a href="https://github.com/mozilla/uniffi-rs/">UniFFI</a> to automatically
generate FFI bindings from the Rust code. It's probably worth a look for your use case, but
is still quite new and may not support everything you need.</p>
<p>If UniFFI doesn't work for you, then you'll need to hand-write the FFI layer.
Here are some earlier blog posts on the topic which might be helpful:</p>
<ul>
<li><a href="https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html">Building and Deploying a Rust library on Android</a></li>
<li><a href="https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-06-rust-on-ios.html">Building and Deploying a Rust library on iOS</a></li>
<li><a href="https://discourse.mozilla.org/t/dear-diary-turns-out-x-platform-is-hard/25348">Blog post re: lessons in binding to Rust code from iOS</a></li>
</ul>
<p>The above are likely to be superceded by uniffi docs, but for now, good luck!</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/building-a-rust-component.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h1>
<p>All names in this project should adhere to the guidelines outlined in this document.</p>
<h2 id="rust-code-2"><a class="header" href="#rust-code-2">Rust Code</a></h2>
<p>TL;DR: do what Rust's builtin warnings and clippy lints tell you
(and CI will fail if there are any unresolved warnings or clippy lints).</p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<ul>
<li>
<p>All variable names, function names, module names, and macros in Rust code should follow typical <code>snake_case</code> conventions. </p>
</li>
<li>
<p>All Rust types, traits, structs, and enum variants must follow <code>UpperCamelCase</code>. </p>
</li>
<li>
<p>Static and constant variables should be written in <code>SCREAMING_SNAKE_CASE</code>. </p>
</li>
<li>
<p>The functions of all component <code>ffi/src/lib.rs</code> files should also follow <code>snake_case</code>, but with an additional prefix based on the library of that function. </p>
</li>
</ul>
<p>For more in-depth Rust conventions, see the <a href="https://doc.rust-lang.org/1.0.0/style/style/naming/README.html">Rust Style Guide</a>.</p>
<h3 id="examples"><a class="header" href="#examples">Examples:</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sync15_passwords_get_all()
struct PushConfiguration{...}
const COMMON_SQL
<span class="boring">}
</span></code></pre></pre>
<h2 id="swift-code-1"><a class="header" href="#swift-code-1">Swift Code</a></h2>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<ul>
<li>
<p>Names of types and protocols are <code>UpperCamelCase</code>.</p>
</li>
<li>
<p>All other uses are <code>lowerCamelCase</code>.</p>
</li>
<li>
<p>Concerning this project, when dealing with Swift code, use Rust convention for FFI binding files (e.g. <code>RustFxAFFI.h</code>).</p>
</li>
</ul>
<p>For more in-depth Swift conventions, check out the <a href="https://swift.org/documentation/api-design-guidelines/">Swift API Design Guidelines</a>.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples:</a></h3>
<pre><code class="language-swift">enum CheckChildren{...}
func checkTree()
public var syncKey: String
</code></pre>
<h2 id="kotlin-code-1"><a class="header" href="#kotlin-code-1">Kotlin Code</a></h2>
<p>If a source file contains only a top-level class, the source file should reflect the case-sensitive name of the class plus the <em>.kt</em> extension. Otherwise, if the source contains multiple top-level declarations, choose a name that describes the contents of the file, apply <code>UpperCamelCase</code> and append <code>.kt</code> extension.</p>
<h3 id="overview-2"><a class="header" href="#overview-2">Overview</a></h3>
<ul>
<li>
<p>Names of packages are always lower case and do not include underscores. Using multi-word names should be avoided. However, if used, they should be concatenated or use <code>lowerCamelCase</code>.</p>
</li>
<li>
<p>Names of classes and objects use <code>UpperCamelCase</code>.</p>
</li>
<li>
<p>Names of functions, properties, and local variables use <code>lowerCamelCase</code>.</p>
</li>
</ul>
<p>For more in-depth Kotlin Conventions, see the <a href="https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules">Kotlin Style Guide</a>.</p>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples:</a></h3>
<pre><code class="language-kotlin">//FooBar.kt
class FooBar{...}
fun fromJSONString()
package mozilla.appservices.places
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/naming-conventions.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="converting-an-existing-component-to-use-uniffi"><a class="header" href="#converting-an-existing-component-to-use-uniffi">Converting an existing Component to use UniFFI</a></h1>
<p>When we started building the components in this repo, exposing Rust code to
Kotlin and Swift was a manual process and each component had its own
hand-written FFI layer and foreign-language bindings.</p>
<p>As we've gained more experience with building components in this way, we've
started to automate bindings generation and capture best practices in a
tool called <a href="https://mozilla.github.io/uniffi-rs/">UniFFI</a>, which is the
currently recommended approach when <a href="howtos/./adding-a-new-component.html">adding a new component from scratch</a>.</p>
<p>We expect that existing components will gradually be ported over to use
UniFFI, and this document is a guide to doing that port.</p>
<h2 id="first-get-familiar-with-uniffi"><a class="header" href="#first-get-familiar-with-uniffi">First, get familiar with UniFFI</a></h2>
<p>First, make sure you've perused the <a href="https://mozilla.github.io/uniffi-rs/">UniFFI guide</a>
to understand the overall architecture of a UniFFI component, and take a look
at the <a href="howtos/./adding-a-new-component.html">guide to adding a new component</a> to understand
how such components fit in to this repo. The aim of porting will be to have a component
that looks like it was added by the process described therein.</p>
<h2 id="next-get-familiar-with-the-target-component"><a class="header" href="#next-get-familiar-with-the-target-component">Next, get familiar with the target component</a></h2>
<p>Pre-UniFFI components typically consist of four main parts:</p>
<ul>
<li>A Rust crate implementing the core functionality of the component</li>
<li>A separate Rust crate that exposes the core functionality over a C-style FFI.</li>
<li>An Android package that imports the C-style FFI into idiomatic Kotlin.</li>
<li>A Swift module that imports the C-style FFI into idiomatic Swift.</li>
</ul>
<p>The code for these parts will be laid out something like this:</p>
<ul>
<li><code>components/&lt;component_name&gt;/</code>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>src/</code>
<ul>
<li>Rust code for the core functionality of the component goes here.</li>
</ul>
</li>
<li><code>ffi/</code>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>src/</code>
<ul>
<li>Rust code specifically for exposing the C-style FFI goes here.</li>
</ul>
</li>
</ul>
</li>
<li><code>android/</code>
<ul>
<li><code>build.gradle</code></li>
<li><code>src/</code>
<ul>
<li><code>main/</code>
<ul>
<li><code>AndroidManifest.xml</code></li>
<li><code>java/mozilla/appservices/&lt;component_name&gt;/</code>
<ul>
<li><code>Lib&lt;ComponentName&gt;FFI.kt</code> (low-level bindings to the C-style FFI)</li>
<li>Higher-level hand-written Kotlin that wraps the FFI.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>ios/</code>
<ul>
<li><code>&lt;component_name&gt;/</code>
<ul>
<li><code>Rust&lt;ComponentName&gt;API.h</code> (low-level bindings to the C-style FFI)</li>
<li>Higher-level hand-written Swift that wraps the FFI.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The goal here is to replace much of the hand-written wrapper layers with autogenerated
code:</p>
<ul>
<li>The <code>./ffi/</code> crate will disappear entirely, its work is automated by UniFFI
<ul>
<li>If you still need some hand-written <code>pub extern &quot;C&quot;</code> functions, perhaps to
implement features not currently supported by UniFFI, then they should move
into <code>lib.rs</code> of the main component crate.</li>
</ul>
</li>
<li>The low-level <code>Lib&lt;ComponentName&gt;FFI.kt</code> file will disappear entirely, as will some of the
code that converts it back into nice high-level Kotlin classes and interfaces.
<ul>
<li>Some of the hand-written Kotlin code may remain, if it provides functionality that
cannot be implemented in Rust.</li>
</ul>
</li>
<li>The low-level <code>Rust&lt;ComponentName&gt;API.h</code> file will disappear entirely, as will some of the
code that converts it back into nice high-level Swift classes and interfaces.
<ul>
<li>Some of the hand-written Swift code may remain, if it provides functionality that
cannot be implemented in Rust.</li>
</ul>
</li>
</ul>
<p>You'll aim to end up with a simplified file structure that looks like this:</p>
<ul>
<li><code>components/&lt;component_name&gt;/</code>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>uniffi.toml</code></li>
<li><code>src/</code>
<ul>
<li><code>&lt;component_name&gt;.udl</code> (abstract interface definition)</li>
<li>Rust code here.</li>
</ul>
</li>
<li><code>android/</code>
<ul>
<li><code>build.gradle</code></li>
<li><code>src/</code>
<ul>
<li><code>main/</code>
<ul>
<li><code>AndroidManifest.xml</code></li>
<li><code>java/mozilla/appservices/&lt;component_name&gt;/</code>
<ul>
<li>Optional hand-written Kotlin code here.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>ios/</code>
<ul>
<li><code>&lt;component_name&gt;/</code>
<ul>
<li>Optional hand-written Swift code here.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="write-a-first-draft-of-the-udl-file-for-the-components-interface"><a class="header" href="#write-a-first-draft-of-the-udl-file-for-the-components-interface">Write a first draft of the <code>.udl</code> file for the component's interface</a></h2>
<p>Make sure you've got the <code>uniffi-bindgen</code> command available; <code>cargo install uniffi_bindgen</code> will
ensure you have the latest version.</p>
<p>Create <code>./src/&lt;component_name&gt;.udl</code> and try to describe the intended interface for the component
using <a href="https://mozilla.github.io/uniffi-rs/udl_file_spec.html">UniFFI's interface definition language</a>.
You'll probably need to reverse-engineer it a little bit from the existing hand-written Kotlin and/or
Swift code.</p>
<p>Don't spend too much time on trying to match every minute detail of the existing hand-written API.
There are likely to be small differences between how UniFFI likes to do things and how the hand-written
APIs were structured, and it's in everyone's best long-term interests to just push ahead and update
consumers to accommodate any breaking API changes, rathern than e.g. trying to convince UniFFI to
capitalize enum variant names in the same style that the hand-written code was using.</p>
<p>To check whether the <code>.udl</code> file is syntactically valid, you can use <code>uniffi-bindgen</code> to generate
the Rust FFI scaffolding like so:</p>
<pre><code>uniffi-bindgen scaffolding ./src/&lt;component_name&gt;.udl
</code></pre>
<p>If this succeeds, it will generate a file <code>./src/&lt;component_name&gt;.uniffi.rs</code> with a bunch of
thorny auto-generated Rust code. If it fails, it will likely fail with an inscrutable error message.
Unfortunately the error reporting in UniFFI is currently a known pain point, and it can take a
bit of trial-and-error to identify what part of the file is causing the issue. Sorry :-(</p>
<p>The aim at this point is to ensure that the intended interface of the component can be expressed
in terms that UniFFI understands. Most cases should be supported, but you may find some aspect of
the existing component that is hard to express in UniFFI, perhaps even uncovering new functionality
that needs to be added to UniFFI itself!</p>
<p>The <code>.udl</code> file is definitely a first draft at this point. It is normal and expected to need
to iterate on this file as you port over the underlying Rust code.</p>
<h2 id="restructure-the-rust-code-to-introduce-uniffi"><a class="header" href="#restructure-the-rust-code-to-introduce-uniffi">Restructure the Rust code to introduce UniFFI</a></h2>
<p>You will now restructure the existing Rust crate so that its public API surface
and overall &quot;shape&quot; match what you defined in the <code>.udl</code> file.</p>
<p>Start by deleting the <code>./ffi</code> sub-crate, because you're going to use UniFFI to generate
all of that code. You'll also need to remove it from the workspace in the top-level
<code>Cargo.toml</code> file, as well as change the crates under <code>/megazords</code> to import the core
Rust crate for the component rather than importing the FFI sub-crate.</p>
<p>Add UniFFI to the crate's dependencies and configure its <code>build.rs</code> script to invoke the
UniFFI scaffolding generator, as described in <a href="howtos/adding-a-new-component.html">&quot;adding a new component&quot;</a>.</p>
<p>Now, edit <code>./lib.rs</code> so that it matches the interface defined in the <code>.udl</code> file as closely
as possible. If the <code>.udl</code> has an <code>interface Example</code> then <code>lib.rs</code> should contain a
<code>pub struct Example</code>, if the <code>.udl</code> contains an <code>enum ExampleItem</code> then <code>lib.rs</code> should
contain a <code>pub enum ExampleItem</code>, and so-on.</p>
<p>The details of this step will depend heavily on the specific crate, but some tips include:</p>
<ul>
<li>
<p>You may find it useful to move all of the existing code into a sub-module named <code>internal</code>,
and then make a brand new <code>lib.rs</code> that imports or re-defines just the pieces it needs
in order to implement the interface from the <code>.udl</code> file. The <code>fxa-client</code> crate is an
example of a case where this worked out well, though of course your mileage may vary.</p>
</li>
<li>
<p>If the existing crate contains a file named like <code>&lt;component_name&gt;_msg_types.proto</code>, then
it was using Protocol Buffers to serialize data to pass over the FFI. The message types
defined in the <code>.proto</code> file will need to be converted into <code>dictionary</code> or <code>enum</code> definitions
in your <code>.udl</code> file. See the section below for more details.</p>
</li>
</ul>
<p>As noted above, don't be afraid to accept some API churn during the conversion process.
We're willing to accept some breaking API changes as the cost of getting bindings generated
for free, as long as the core functionality and mental model of the component remain intact.</p>
<p>At this point, in theory the crate should be buildable with UniFFI, although it's likely
to require some iteration to get it all working! Run <code>cargo check</code> to check for any
compilation errors without having to do a full build.</p>
<h3 id="removing-protobuf-messages"><a class="header" href="#removing-protobuf-messages">Removing Protobuf Messages</a></h3>
<p>Passing rich structured data over the FFI is the most complex part of our hand-written bindings,
and was previously done by <a href="https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/">serializing data via Protocol Buffers</a>.
This is something that UniFFI tries to make as simple as possible.</p>
<p>Start by locating the <code>&lt;component_name&gt;_msg_types.proto</code> file for the component. This file defines
the structured messages that can be passed over the FFI, and you should see that they correspond
to various types of structured data that the component wants to receive from, or return to,
the foreign-language code.</p>
<p>Find the places in your <code>.udl</code> interface that correspond to these message types and make sure
that you've got a similarly-shaped <code>dictionary</code> or <code>enum</code> for each one. You should find that
representing this structured data in UDL is simpler than protobuf in many cases - for example
many of our <code>.protobuf</code> files need to use a separate <code>ExampleStructs</code> message in order to
pass a list of <code>ExampleStruct</code> messages over the FFI, but in UniFFI this is represented
directly as <code>sequence&lt;ExampleStruct&gt;</code>.</p>
<p>Find the places in the Rust code that are using these message types to return structured data.
In simple cases, you may be able to directly replace uses of <code>msg_types::ExampleStruct</code> with
the corresponding <code>crate::ExampleStruct</code> from your public API.
For more complex cases, you may find it helpful to define an <code>Into</code> mapping between the
UniFFI dictionary/enum in the crate's public interface, and a more complex struct designed
for internal use.</p>
<p>As noted above, don't be afraid to accept some API churn during this conversion process.</p>
<p>Once you have replaced all uses of the <code>msg_types</code> structs in the Rust code:</p>
<ul>
<li>Delete <code>./src/&lt;component_name&gt;_msg_types.proto</code>.</li>
<li>Delete <code>./src/mozilla.appservices.&lt;component_name&gt;.protobuf.rs</code>, which is generated from the <code>.proto</code> file.</li>
<li>Remote <code>prost</code> and <code>prost-derive</code> from the crate's dependencies.</li>
<li>Delete the crate from the list in <code>/tools/protobuf_files.toml</code>.</li>
</ul>
<p>If you happen to find that you've deleted the last crate from the list in <code>protobuf_files.toml</code>,
congratulations! You've successfully removed protocol buffers from this repo entirely, and should
file a bug to track the complete removal of protobuf from our tooling and dependency chain.</p>
<h2 id="document-the-public-api-in-the-rust-code"><a class="header" href="#document-the-public-api-in-the-rust-code">Document the Public API in the Rust code</a></h2>
<p>Write consumer-facing documentation on the public API in <code>lib.rs</code> using Rust's standard
<a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html">rustdoc</a> conventions
and tools. The <code>fxa-client</code> crate may serve as a good example.</p>
<p>You can view the generated documentation by running:</p>
<pre><code>cargo doc --no-deps --open
</code></pre>
<p>In future, we intend to automatically extract documentation from the Rust code
and make it easily available to consumers of the generated bindings.</p>
<p>(In fact there is some work-in-progress code in <a href="https://github.com/mozilla/uniffi-rs/pull/416">uniffi-rs#416</a>
that can read docs from the Rust code and write them back into the <code>.udl</code> file, which you're
welcome to try out if you're feeling adventurous. But it's just a very hacky prototype.)</p>
<h2 id="set-up-the-kotlin-wrapper"><a class="header" href="#set-up-the-kotlin-wrapper">Set up the Kotlin wrapper</a></h2>
<p>It's easiest to start by removing all of the hand-written Kotlin code under <code>android/src/main/java</code>
and then restoring parts of it later if necessary. Leave the <code>AndroidManifest.xml</code> file and any tests
in place.</p>
<p>Delete the <code>android/build.gradle</code> file and then follow the instructions for <a href="howtos/adding-a-new-component.html#the-kotlin-bindings">adding Kotlin bindings
for a new component</a> to create a new <code>build.gradle</code>
file and a corresponding <code>uniffi.toml</code>.</p>
<p>This should be all that's required to set up UniFFI to build the Kotlin bindings. Try building
the Android package to confirm:</p>
<ul>
<li><code>./gradlew &lt;component_name&gt;:assembleDebug</code></li>
</ul>
<p>The UniFFI-generated Kotlin code will be under <code>./android/build/generated/source/uniffi/</code> and
may be useful for debugging.</p>
<p>If there are existing Kotlin tests for the component, the next step is to get those passing:</p>
<ul>
<li><code>./gradlew &lt;component_name&gt;:test</code></li>
</ul>
<p>As noted above, it is normal and expected for the autogenerated bindings to be subtly different
from the previous hand-written ones. For example, UniFFI insists on using SHOUTY_SNAKE_CASE
variant names in Kotlin enums while the hand-written code may have used CamelCase. Some components
also have small naming differences between the Rust code and the hand-written Kotlin bindings,
which UniFFI will not allow.</p>
<p>If the component had functionality in its Kotlin layer that was not part of the Rust API,
then you'll need to add some hand-written Kotlin code under <code>android/src/main/java</code> to
implement it. The <code>fxa-client</code> component may be a good example here: its Rust layer exposes
a <code>FirefoxAccount</code> struct that the Kotlin code wraps into a <code>PersistedFirefoxAccount</code> class,
adding the ability to set a persistence callback.</p>
<p>Finally, you will need to try out the new bindings with a consuming app. For Kotlin code you should
<a href="howtos/locally-published-components-in-fenix.html">make a local build of android-components and Fenix</a>,
updating them to accomodate any changes in the component's public API.</p>
<h2 id="set-up-the-swift-wrapper"><a class="header" href="#set-up-the-swift-wrapper">Set up the Swift wrapper</a></h2>
<p>It's easiest to start by removing all of the hand-written Swift code under <code>./ios</code> and then
restoring parts of it later if necessary.</p>
<p>Edit <code>/megazords/ios/MozillaAppServices.h</code> to remove any references to <code>Rust&lt;ComponentName&gt;API.h</code>,
replacing them with the UniFFI-generated header file name <code>uniffi_&lt;component_name&gt;-Bridging-Header.h</code>.</p>
<p>Open <code>/megazords/ios/MozillaAppServices.xcodeproj</code> in XCode and follow the instructions for
<a href="howtos/adding-a-new-component.html#the-swift-bindings">adding Swift bindings for a new component</a> to
configure XCode to build your UniFFI-generated bindings.</p>
<p>While you are in the XCode Project Navigator, you should also delete any references to
<code>Rust&lt;ComponentName&gt;API.h</code> or to the old hand-written Swift wrappers. (They should be highlighted
in red in the Project Navigator, because the files will be missing from disk after you
deleted them above).</p>
<p>This should be all that's required to set up UniFFI to build the Swift bindings. Try building
the project in XCode to confirm.</p>
<p>The UniFFI-generated Swift code will be under <code>ios/Generated</code> and may be useful for debugging.</p>
<p>If there are existing Swift tests for the component, the next step is to get those passing:</p>
<ul>
<li><code>./automation/run_ios_tests.sh</code></li>
<li>(or run them from the XCode GUI)</li>
</ul>
<p>As noted above, it is normal and expected for the autogenerated bindings to be subtly different
from the previous hand-written ones. Many existing components have small naming differences
between the Rust code and the hand-written Swift bindings, which UniFFI will not allow.</p>
<p>If the component had functionality in its Swift layer that was not part of the Rust API,
then you'll need to add some hand-written Swift code under <code>./ios/&lt;ComponentName&gt;</code> to
implement it. The <code>fxa-client</code> component may be a good example here: its Rust layer exposes
a <code>FirefoxAccount</code> struct that the Swift code wraps into a <code>PersistedFirefoxAccount</code> class,
adding the ability to set a persistence callback.</p>
<p>You will need to add any such file to the &quot;Compile Sources&quot; list in XCode, in the same way
that you added the <code>.udl</code> file.</p>
<p>Finally, you will need to try out the new bindings with a consuming app. For Swift code you should
<a href="howtos/locally-published-components-in-ios.html">make a local build of Firefox for iOS</a>,
updating it to accomodate any changes in the component's public API.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/converting-a-component-to-uniffi.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="when-to-use-what-method-of-passing-data-between-rust-and-javaswift"><a class="header" href="#when-to-use-what-method-of-passing-data-between-rust-and-javaswift">When to use what method of passing data between Rust and Java/Swift</a></h1>
<p>There are a bunch of options here. For the purposes of our discussion,
there are two kinds of values you may want to pass over the FFI.</p>
<ol>
<li>Types with identity (includes stateful types, resource types, or anything that
isn't really serializable).</li>
<li>Plain ol' data.</li>
</ol>
<h2 id="types-with-identity"><a class="header" href="#types-with-identity">Types with identity</a></h2>
<p>Examples of this are things like database connections, the FirefoxAccounts
struct, etc. These types are complex, implemented in rust, and it's not
unreasonable for them to come to Java/Kotlin as a type representing a
resource (e.g. implementing <code>Closable</code>/<code>AutoClosable</code>).</p>
<p>You have two choices here:</p>
<ol>
<li>
<p>Use a <code>ConcurrentHandleMap</code> to store all instances of your object, and
pass the handle back and forth as a u64 from Rust / Long from Kotlin.</p>
<p>This is recommended for most cases, as it's the hardest to mess up.
Additionally, for types T such that <code>&amp;T: Sync + Send</code>, or that you
need to call <code>&amp;mut self</code> method, this is the safest choice.</p>
<p>Additionally, this will ensure panic-safety, as you'll poison your Mutex.</p>
<p>The <a href="https://docs.rs/ffi-support/*/ffi_support/handle_map/index.html"><code>ffi_support::handle_map</code> docs</a>
are good, and under <code>ConcurrentHandleMap</code> include an example of how to set
this up. You can also look at most of the FFI crates, as they do this (with
the exception of <code>rc_log</code>, which has unique requirements).</p>
</li>
<li>
<p>Using an opaque pointer. This is generally only recommended for rare cases
like the <code>PlacesInterruptHandle</code> (or the <code>LogAdapterState</code> from <code>rc_log</code>,
although it will probably eventually use a handle).</p>
<p>It's good if your synchronization or threading requirements are somewhat
complex and handled separately, such that the additional overhead of
the <code>ConcurrentHandleMap</code> is undesirable. You should probably talk to us
before adding another type that works this way, to make sure it's sound.</p>
<p>The <a href="https://docs.rs/ffi-support/*/ffi_support/macro.implement_into_ffi_by_pointer.html"><code>ffi_support</code> docs</a>
discuss how to do this, or take a look at how it's done for
<code>PlacesInterruptHandle</code>).</p>
</li>
</ol>
<h2 id="plain-old-data"><a class="header" href="#plain-old-data">Plain Old Data</a></h2>
<p>This includes both primitive values, strings, arrays, or arbitrarially nested
structures containing them.</p>
<h3 id="primitives"><a class="header" href="#primitives">Primitives</a></h3>
<p>Specifically numeric primitives. These we'll tackle first since they're the
easiest.</p>
<p>In general, you can just pass them as you wish. There are a couple of
exceptions/caveats. All of them are caused by JNA/Android issues (Swift has very
good support for calling over the FFI), but it's our lowest common denominator.</p>
<ol>
<li>
<p><code>bool</code>: Don't use it. JNA doesn't handle it well. Instead, use a numeric type
(like <code>u8</code>) and represent 0 for false and 1 for true for interchange over the
FFI, converting back to a Kotlin <code>Boolean</code> or swift <code>Bool</code> after (as to
not expose this somewhat annoying limitation in our public API).</p>
</li>
<li>
<p><code>usize</code>/<code>isize</code>: These cause the structure size to be different based on the
platform. JNA does handle this if you use <code>NativeSize</code>, but it's awkward,
incompatible with it's Direct Mapping optimization (which we don't use but
want to in the future), and has more overhead than just using <code>i64</code>/<code>i32</code> for
<code>Long</code>/<code>Int</code>. (You can also use <code>u64</code>/<code>u32</code> for <code>Long</code>/<code>Int</code>, if you're certain the
value is not negative)</p>
</li>
<li>
<p><code>char</code>: I really don't see a reason you need to pass a single codepoint over the
FFI, but if someone needs to do this, they instead should just pass it as a <code>u32</code>.</p>
<p>If you do this, you should probably be aware of the fact that Java chars are 16
bit, and Swift <code>Character</code>s are actually strings (they represent Extended
Grapheme Clusters, not codepoints).</p>
</li>
</ol>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>These we pass as nul-terminated UTF-8 C-strings.</p>
<p>For return values, used <code>*mut c_char</code>, and for input, use
<a href="https://docs.rs/ffi-support/*/ffi_support/struct.FfiStr.html"><code>ffi_support::FfiStr</code></a></p>
<ol>
<li>
<p>If the string is returned from Rust to Kotlin/Swift, you need to expose a
string destructor from your ffi crate. See
<a href="https://docs.rs/ffi-support/*/ffi_support/macro.define_string_destructor.html"><code>ffi_support::define_string_destructor!</code></a>).</p>
<p>For converting to a <code>*mut c_char</code>, use either
<a href="https://docs.rs/ffi-support/*/ffi_support/fn.rust_string_to_c.html"><code>rust_string_to_c</code></a>
if you have a <code>String</code>, or
<a href="https://docs.rs/ffi-support/*/ffi_support/fn.opt_rust_string_to_c.html"><code>opt_rust_string_to_c</code></a>
for <code>Option&lt;String&gt;</code> (None becomes <code>std::ptr::null_mut()</code>).</p>
<p><strong>Important</strong>: In Kotlin, the type returned by a function that produces this
must be <code>Pointer</code>, and not <code>String</code>, and the parameter that the destructor takes
as input must also be <code>Pointer</code>.</p>
<p>Using <code>String</code> will <em>almost</em> work. JNA will convert the return value to
<code>String</code> automatically, leaking the value rust provides. Then, when passing
to the destructor, it will allocate a temporary buffer, pass it to Rust, which
we'll free, corrupting both heaps . Oops!</p>
</li>
<li>
<p>If the string is passed into Rust from Kotlin/Swift, the rust code should
declare the parameter as a <a href="https://docs.rs/ffi-support/*/ffi_support/struct.FfiStr.html"><code>FfiStr&lt;'_&gt;</code></a>.
and things should then work more or less automatically. The <code>FfiStr</code> has methods
for extracting it's data as <code>&amp;str</code>, <code>Option&lt;&amp;str&gt;</code>, <code>String</code>, and <code>Option&lt;String&gt;</code>.</p>
</li>
</ol>
<p>It's also completely fine to use Protobufs or JSON for this case!</p>
<h3 id="aggregates"><a class="header" href="#aggregates">Aggregates</a></h3>
<p>This is any type that's more complex than a primitive or a string (arrays,
structures, and combinations there-in). There are two options we recommend for
these cases:</p>
<ol>
<li>
<p>Passing data using protobufs. See the
&quot;<a href="howtos/passing-protobuf-data-over-ffi.html">Using protobuf-encoded data over Rust FFI</a>&quot;
document for details on how to do this. We recommend this for all new use cases, unless
you have a specific reason that JSON is better (e.g. semi-opaque JSON encoded data is
desired on the other side).</p>
</li>
<li>
<p>Passing data as JSON. This is very easy, and useful for prototyping, however
much slower, requires a great deal of copying and redundant encode/decode
steps (in general, the data will be copied at least 4 times to make this
work, and almost certainly more in practice), and can be done relatively
easily by <code>derive(Serialize, Deserialize)</code>, and adding
<a href="https://docs.rs/ffi-support/*/ffi_support/macro.implement_into_ffi_by_json.html"><code>ffi_support::implement_into_ffi_by_json</code></a>
into the crate that defines the type.</p>
<p>Again, for new code, this is not a recommended approach for new code, unless
there's some reason it's preferrable for you.</p>
</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/when-to-use-what-in-the-ffi.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rust--android-faqs"><a class="header" href="#rust--android-faqs">Rust + Android FAQs</a></h1>
<h3 id="how-do-i-expose-rust-code-to-kotlin"><a class="header" href="#how-do-i-expose-rust-code-to-kotlin">How do I expose Rust code to Kotlin?</a></h3>
<p>Use <a href="https://mozilla.github.io/uniffi-rs/">UniFFI</a>, which can produce Kotlin
bindings for your Rust code from an interface definition file.</p>
<p>If UniFFI doesn't currently meet your needs, please <a href="https://github.com/mozilla/uniffi-rs/issues">open an issue</a> to discuss how the tool can
be improved.</p>
<p>As a last resort, you can make hand-written bindings from Rust to Kotlin,
essentially manually performing the steps that UniFFI tries to automate
for you: flatten your Rust API into a bunch of <code>pub extern &quot;C&quot;</code> functions,
then use <a href="https://github.com/java-native-access/jna">JNA</a> to call them
from Kotlin. The details of how to do that are well beyond the scope of
this document.</p>
<h3 id="how-should-i-name-the-package"><a class="header" href="#how-should-i-name-the-package">How should I name the package?</a></h3>
<p>Published packages should be named <code>org.mozilla.appservices.$NAME</code> where <code>$NAME</code>
is the name of your component, such as <code>logins</code>.  The Java namespace in which
your package defines its classes etc should be <code>mozilla.appservices.$NAME.*</code>.</p>
<h3 id="how-do-i-publish-the-resulting-package"><a class="header" href="#how-do-i-publish-the-resulting-package">How do I publish the resulting package?</a></h3>
<p>Add it to <code>.buildconfig-android.yml</code> in the root of this repository.
This will cause it to be automatically included as part of our release
publishing pipeline.</p>
<h3 id="how-do-i-know-what-library-name-to-load-to-access-the-compiled-rust-code"><a class="header" href="#how-do-i-know-what-library-name-to-load-to-access-the-compiled-rust-code">How do I know what library name to load to access the compiled rust code?</a></h3>
<p>Assuming that you're building the Rust code as part of the application-services
build and release process, your <code>pub extern &quot;C&quot;</code> API should always be available
from a file named <code>libmegazord.so</code>.</p>
<h3 id="what-challenges-exist-when-calling-back-into-kotlin-from-rust"><a class="header" href="#what-challenges-exist-when-calling-back-into-kotlin-from-rust">What challenges exist when calling back into Kotlin from Rust?</a></h3>
<p>There are a number of them. The issue boils down to the fact that you need to be
completely certain that a JVM is associated with a given thread in order to call
java code on it. The difficulty is that the JVM can GC its threads and will not
let rust know about it.</p>
<p>JNA can work around this for us to some extent, at the cost of some complexity.
The approach it takes is essentially to spawn a thread for each callback
invocation. If you are certain youre going to do a lot of callbacks and they
all originate on the same thread, you can have them all run on a single thread
by using the <a href="https://java-native-access.github.io/jna/4.2.1/com/sun/jna/CallbackThreadInitializer.html"><code>CallbackThreadInitializer</code></a>.</p>
<p>With the help of JNA's workarounds, calling back from Rust into Kotlin isnt too bad
so long as you ensure that Kotlin cannot GC the callback while rust code holds onto it
(perhaps by stashing it in a global variable), and so long as you can either accept the overhead of extra threads being instantiated on each call or are willing to manage
the threads explicitly.</p>
<p>Note that the situation would be somewhat better if we used JNI directly (and
not JNA), but this would cause us to need to generate different Rust FFI code for
Android than for iOS.</p>
<p>Ultimately, in any case where there is an alternative to using a callback, you
should probably pursue that alternative.</p>
<p>For example if you're using callbacks to implement async I/O, it's likely better to
move to doing a blocking call, and have the calling code dispatch it on a background
thread. Its very easy to run such things on a background thread in Kotlin, is in line
with the Android documentation on JNI usage, and in our experience is vastly simpler
and less painful than using callbacks.</p>
<p>(Of course, not every case is solvable like this).</p>
<h3 id="why-are-we-using-jna-rather-than-jni-and-what-tradeoffs-does-that-involve"><a class="header" href="#why-are-we-using-jna-rather-than-jni-and-what-tradeoffs-does-that-involve">Why are we using JNA rather than JNI, and what tradeoffs does that involve?</a></h3>
<p>We get a couple things from using JNA that we wouldn't with JNI.</p>
<ol>
<li>
<p>We are able to use the same Rust FFI code on all platforms. If we used JNI we'd
need to generate an Android-specific Rust FFI crate that used the JNI APIs, and
a separate Rust FFI crate for exposing to Swift.</p>
</li>
<li>
<p>JNA provides a mapping of threads to callbacks for us, making callbacks over
the FFI possible. That said, in practice this is still error prone, and easy
to misuse/cause memory safety bugs, but it's required for cases like logging,
among others, and so it is a nontrivial piece of complexity we'd have to
reimplement.</p>
</li>
</ol>
<p>However, it comes with the following downsides:</p>
<ol>
<li>JNA has bugs. In particular, its not safe to use bools with them, it thinks
they are 32 bits, when on most platforms (every platform Rust supports) they
are 8 bits. They've been unwilling to fix the issue due to it breaking
backwards compatibility (which is... somewhat fair, there is a lot of C89
code out there that uses <code>bool</code> as a typedef for a 32-bit <code>int</code>).</li>
<li>JNA makes it really easy to do the wrong thing and have it work but corrupt
memory. Several of the caveats around this are documented in the
<a href="https://docs.rs/ffi-support/*/ffi_support/"><code>ffi_support</code> docs</a>, but a
major one is when to use <code>Pointer</code> vs <code>String</code> (getting this wrong will
often work, but may corrupt memory).</li>
</ol>
<p>We aim to avoid triggering these bugs by auto-generating the JNA bindings
rather than writing them by hand.</p>
<h3 id="how-do-i-debug-rust-code-with-the-step-debugger-in-android-studio"><a class="header" href="#how-do-i-debug-rust-code-with-the-step-debugger-in-android-studio">How do I debug Rust code with the step-debugger in Android Studio</a></h3>
<ol>
<li>Uncomment the <code>packagingOptions { doNotStrip &quot;**/*.so&quot; }</code> line from the
build.gradle file of the component you want to debug.</li>
<li>In the rust code, either:
<ol>
<li>Cause something to crash where you want the breakpoint. Note: Panics
don't work here, unfortunately. (I have not found a convenient way to
set a breakpoint to rust code, so
<code>unsafe { std::ptr::write_volatile(0 as *const _, 1u8) }</code> usually is
what I do).</li>
<li>If you manage to get an LLDB prompt, you can set a breakpoint using
<code>breakpoint set --name foo</code>, or <code>breakpoint set --file foo.rs --line 123</code>.
I don't know how to bring up this prompt reliably, so I often do step 1 to
get it to appear, delete the crashing code, and then set the
breakpoint using the CLI. This is admittedly suboptimal.</li>
</ol>
</li>
<li>Click the Debug button in Android Studio, to display the &quot;Select Deployment
Target&quot; window.</li>
<li>Make sure the debugger selection is set to &quot;Both&quot;. This tends to unset
itself, so make sure.</li>
<li>Click &quot;Run&quot;, and debug away.</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/android-faqs.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="guide-to-consuming-rust-components-on-ios"><a class="header" href="#guide-to-consuming-rust-components-on-ios">Guide to Consuming Rust Components on iOS</a></h1>
<p>The application services libraries are published as a zip file containing a single composite (megazord) framework called <em>MozillaAppServices.framework</em>,
which contains the compiled code for all components.</p>
<p>The package is published as a release on github: https://github.com/mozilla/application-services/releases</p>
<h2 id="carthage"><a class="header" href="#carthage">Carthage</a></h2>
<ul>
<li>Add the dependency line to the Cartfile, for instance: <code>github &quot;mozilla/application-services&quot; ~&gt; &quot;v0.16.1&quot;</code> </li>
<li><code>carthage</code> will download MozillaAppServices.frameworks.zip, and add all the available frameworks to the 'Carthage/' dir.</li>
<li>Link against the provided MozillaAppServices.framework (in the <em>Link Binary with Libraries</em> step in your Xcode target).</li>
<li>Add additional dependencies, see <a href="howtos/consuming-rust-components-on-ios.html#additional-dependencies">below</a>.</li>
</ul>
<h3 id="adding-a-carthage-provided-framework-to-xcode"><a class="header" href="#adding-a-carthage-provided-framework-to-xcode">Adding a carthage provided framework to Xcode</a></h3>
<ul>
<li>In general, to do this, add <em>XXX.framework</em> from <em>Carthage/Build/iOS</em> to <em>Link binary with Libraries</em> for the Xcode target.</li>
<li>Update the list of additional dependencies below, so that consumers know to include the framework in their final build.</li>
</ul>
<h3 id="using-a-circle-ci-built-framework"><a class="header" href="#using-a-circle-ci-built-framework">Using a Circle-CI built framework</a></h3>
<p>Rather than using a tagged release version, one can grab the build from Circle-CI, like so:</p>
<p><code>binary &quot;https://circleci.com/api/v1.1/project/github/mozilla/application-services/2862/artifacts/0/dist/mozilla.app-services.json&quot; ~&gt; 0.0.1-snapshot</code></p>
<h2 id="additional-dependencies"><a class="header" href="#additional-dependencies">Additional dependencies</a></h2>
<p>The project has additional 3rd-party dependencies that a client must link against.</p>
<h3 id="nss"><a class="header" href="#nss">NSS</a></h3>
<ul>
<li>In your project, add all the .dylibs in the <code>../Carthage/Build/iOS/MozillaAppServices.framework</code> directory to both the &quot;Embedded Binaries&quot; and the &quot;Linked Frameworks and Libraries&quot; panels.</li>
</ul>
<h3 id="protobuf"><a class="header" href="#protobuf">Protobuf</a></h3>
<ul>
<li><em>SwiftProtoBuf.framework</em> should be automatically downloaded by carthage while pulling in the application-services dependency.</li>
<li><a href="howtos/consuming-rust-components-on-ios.html#adding-a-carthage-provided-framework-to-xcode">Add that framework to Xcode.</a></li>
</ul>
<h2 id="third-party-licenses"><a class="header" href="#third-party-licenses">Third-party licenses</a></h2>
<p>This project incorporates code from a number of third-party dependencies,
under a variety of open-source licenses. You should review the license info
in the file <code>DEPENDENCIES.md</code> and decide on an appropriate way to include
license and attribution notices into your product.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/consuming-rust-components-on-ios.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="application-services-logging"><a class="header" href="#application-services-logging">Application Services Logging</a></h2>
<p>When writing code in application-services, code implemented in Rust, Kotlin,
Java, or Swift might have to write debug logs. To do so, one should generally
log using the normal logging facilities for the language. Where the logs go
depends on the application which is embedding the components.</p>
<h3 id="accessing-logs-when-running-fenix"><a class="header" href="#accessing-logs-when-running-fenix">Accessing logs when running Fenix</a></h3>
<p>On android, logs currently go to logcat. (This may change in the future.)
Android Studio can be used to view the logcat logs; connect the device over USB
and view the Logcat tab at the bottom of Android Studio. Check to make sure you
have the right device selected at the top left of the Logcat pane, and the
correct process to the right of that. One trick to avoid having to select the
correct process (as there are main and content processes) is to choose &quot;No
Filters&quot; from the menu on the top right of the Logcat pane. Then, use the search
box to search for the log messages you are trying to find.</p>
<p>There are also many other utilities, command line and graphical, that can be
used to view logcat logs from a connected android device in a more flexible
manner.</p>
<h4 id="changing-the-loglevel-in-fenix"><a class="header" href="#changing-the-loglevel-in-fenix">Changing the loglevel in Fenix</a></h4>
<p>If you need more verbose logging, after the call to <code>RustLog.enable()</code> in
<code>FenixApplication</code>, you may call <code>RustLog.setMaxLevel(Log.Priority.DEBUG, true)</code>.</p>
<h3 id="accessing-logs-when-running-ios"><a class="header" href="#accessing-logs-when-running-ios">Accessing logs when running iOS</a></h3>
<p>[TODO]</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/logging.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="application-services-release-process"><a class="header" href="#application-services-release-process">Application Services Release Process</a></h1>
<h2 id="make-a-new-release-from-latest-main"><a class="header" href="#make-a-new-release-from-latest-main">Make a new release from latest main.</a></h2>
<ol>
<li>
<p>Smoketest whether the release will integrate cleanly with key downstream consumers:</p>
<ul>
<li>Run the <code>./automation/smoke-test-firefox-ios.py</code> script to test integration with Firefox for iOS.</li>
<li>Run the <code>./automation/smoke-test-android-components.py</code> script to test integration with Android Components.</li>
<li>Run the <code>./automation/smoke-test-fenix.py</code> script to test integration with Fenix</li>
<li>Build and run the <a href="https://github.com/mozilla-mobile/android-components/tree/master/samples/sync">sync sample app</a> in android-components
against your local checkout using the <a href="howtos/./locally-published-components-in-fenix.html">local publishing flow</a>.
If these tests fail, it indicates a breaking change. Check that such a change is called out
in the changelog, and file downstream bugs to track the work of integrating it.</li>
</ul>
</li>
<li>
<p>Run the <code>./automation/prepare-release.py</code> script to create a release commit and open a pull-request. If this script does not work for you, please refer to the &quot;Create a release commit manually&quot; section in this document.</p>
</li>
<li>
<p>Cut the actual release.</p>
<ol>
<li>Click &quot;Releases&quot;, and then &quot;Draft a New Release&quot; in the github UI.</li>
<li>Enter <code>v&lt;myversion&gt;</code> as the tag. It's important this is the same as the tags that are in the changelog.</li>
<li>Under the description, paste the contents of the release notes from CHANGELOG.md.</li>
<li>Note that the release is not avaliable until the taskcluster build completes for that tag.
<ul>
<li>Finding this out takes a little navigation in the github UI. It's available at <code>https://github.com/mozilla/application-services/commits/v&lt;VERSION NUMBER&gt;</code> in the build status info (the emoji) next to the last commit.</li>
<li>If the taskcluster tag and/or release tasks fail, ping someone in slack and we'll figure out what to do.</li>
</ul>
</li>
</ol>
</li>
<li>
<p>If you need to manually produce the iOS build for some reason (for example, if CircleCI cannot), someone with a mac needs to do the following steps:</p>
<ol>
<li>If necessary, set up for performing iOS builds using <code>./libs/verify-ios-environment.sh</code>.</li>
<li>Run <code>./build-carthage.sh</code> in the root of the repository.</li>
<li>Upload the resulting <code>MozillaAppServices.framework.zip</code> as an attachment on the github release.</li>
</ol>
</li>
<li>
<p>In order for consumers to have access, we need to update in <a href="https://github.com/mozilla-mobile/android-components">android-components</a>.</p>
<ol>
<li>
<p>If the changes expose new functionality, or otherwise require changes to code or documentation in https://github.com/mozilla-mobile/android-components, perform those. This part is often done at the same time as the changes in application-services, to avoid being blocked on steps 3-4 of this document.</p>
</li>
<li>
<p>Change the versions of our dependencies in <a href="https://github.com/mozilla-mobile/android-components/blob/master/buildSrc/src/main/java/Dependencies.kt">buildSrc/src/main/java/Dependencies.kt</a>.</p>
</li>
<li>
<p>Note the relevant changes in their <a href="https://github.com/mozilla-mobile/android-components/blob/master/docs/changelog.md">docs/changelog.md</a>, and update the application-services version there as well in their list of dependency versions.</p>
</li>
<li>
<p><em><strong>Important: Manually test the changes versus the samples in android-components.</strong></em></p>
<ul>
<li>We do not have automated test coverage for much of the network functionality at this point, so this is crucial.</li>
<li>You can do this using the smoketest instructions in step (1) above.</li>
</ul>
</li>
<li>
<p>Get it PRed and landed.</p>
</li>
</ol>
</li>
</ol>
<h2 id="make-a-new-point-release-from-an-existing-release-that-is-behind-latest-main"><a class="header" href="#make-a-new-point-release-from-an-existing-release-that-is-behind-latest-main">Make a new point-release from an existing release that is behind latest main.</a></h2>
<ol>
<li>If necessary, make a new branch named <code>release-vXX</code> which will be used for all point-releases on the <code>vXX.YY.ZZ</code>
series. Example:
<pre><code>git checkout -b release-v72 v72.1.0
git push -u origin release-v72
</code></pre>
</li>
<li>Make a new branch with any fixes to be included in the release, <em>remembering not to make any breaking API
changes.</em>. This may involve cherry-picking fixes from main, or developing a new fix directly against the
branch. Example:
<pre><code>git checkout -b fixes-for-v72.1.1 release-v72
git cherry-pick 37d35304a4d1d285c8f6f3ce3df3c412fcd2d6c6
git push -u origin fixes-for-v72.1.1
</code></pre>
</li>
<li>Get a PR up with your changes and land them into the &quot;base&quot; branch.
For example, if you are making a <code>release-v72.1.1</code> release, all the changes
you want in that release must already be in the <code>release-v72</code> branch before
following the steps below.</li>
<li>Follow the above steps for cutting a new release from main, except that:
<ul>
<li>When running the <code>./automation/prepare-release.py</code> script, use the <code>--base-branch</code> argument to point it at your release branch, and specify <code>patch</code> as the release type. Example:
<pre><code>./automation/prepare-release.py --base-branch=release-v72 patch
</code></pre>
</li>
<li>When opening a PR to land the commits, target the <code>release-vXX</code> branch rather than main.</li>
<li>When cutting the new release via github's UI, target the <code>release-vXX</code> branch rather than main.</li>
</ul>
</li>
<li>Merge the new release back to main.
<ul>
<li>This will typically require a PR and involve resolving merge conflicts in the changelog.</li>
<li>This ensures we do not accidentally orphan any fixes that were made directly against the release branch,
and also helps ensure that every release has an easily-discoverable changelog entry in main.</li>
</ul>
</li>
</ol>
<h2 id="create-a-release-commit-manually"><a class="header" href="#create-a-release-commit-manually">Create a release commit manually</a></h2>
<ol>
<li>
<p>Update the changelog.</p>
<ol>
<li>
<p>Copy the contents from <code>CHANGES_UNRELEASED.md</code> into the top of <code>CHANGELOG.md</code>, except for the part that links to this document.</p>
</li>
<li>
<p>In <code>CHANGELOG.md</code>:</p>
<ol>
<li>Replace <code># Unreleased Changes</code> with <code># v&lt;new-version-number&gt; (_&lt;current date&gt;_)</code>.</li>
<li>Replace <code>main</code> in the Full Changelog link (which you pasted in from <code>CHANGES_UNRELEASED.md</code>) to be <code>v&lt;new-version-number&gt;</code>. E.g. if you are releasing 0.13.2, the link should be
<pre><code>[Full Changelog](https://github.com/mozilla/application-services/compare/v0.13.1...v0.13.2)
</code></pre>
Note that this needs three dots (<code>...</code>) between the two tags (two dots is different). Yes, the second tag doesn't exist yet, you'll make it later.</li>
<li>Optionally, go over the commits between the past release and this one and see if anything is worth including.</li>
<li>Make sure the changelog follows the format of the other changelog entries. If you have access, <a href="https://docs.google.com/document/d/1oxdGm7OQcsy78NzXjMQKTbfzn21tl9Nopmvo8NCMWmU">this document</a> is fairly comprehensive. For a concrete example, at the time of this writing, see the <a href="https://github.com/mozilla/application-services/blob/main/CHANGELOG.md#0130-2019-01-09">0.13.0</a> release notes.
<ul>
<li>Note that we try to provide PR or issue numbers (and links) for each change. Please add these if they are missing.</li>
</ul>
</li>
</ol>
</li>
<li>
<p>In <code>CHANGES_UNRELEASED.md</code>:</p>
<ol>
<li>Delete the list of changes that are now in the changelog.</li>
<li>Update the &quot;Full Changelog&quot; link so that it starts at your new version and continues to main. E.g. for 60.0.6 this would be
<pre><code>[Full Changelog](https://github.com/mozilla/application-services/compare/v60.0.6...main)
</code></pre>
Again, this needs 3 dots.</li>
</ol>
</li>
</ol>
</li>
<li>
<p>Bump <code>libraryVersion</code> in the top-level <a href="https://github.com/mozilla/application-services/blob/main/.buildconfig-android.yml">.buildconfig-android.yml</a> file. Be sure you're following semver, and if in doubt, ask.</p>
</li>
<li>
<p>Land the commits that perform the steps above. This takes a PR, typically, because of branch protection on main.</p>
</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/cut-a-new-release.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="megazording"><a class="header" href="#megazording">Megazording</a></h1>
<p>Each Rust component published by Application Services is conceptually a stand-alone library, but for
distribution we compile all the rust code for all components together into a single <code>.so</code> file. This
has a number of advantages:</p>
<ul>
<li>Easy and direct interoperability between different components at the Rust level</li>
<li>Cross-component optimization of generated code</li>
<li>Reduced code size thanks to distributing a single copy of the rust stdlib, low-level dependencies, etc.</li>
</ul>
<p>This process is affectionately known as &quot;megazording&quot; and the resulting artifact as a <em><strong>megazord library</strong></em>.</p>
<p>On Android, the situation is quite complex due to the way packages and dependencies are managed.
We need to distribute each component as a separate Android ARchive (AAR) that can be managed as a dependency
via gradle, we need to provide a way for the application to avoid shipping rust code for components that it
isn't using, and we need to do it in a way that maintanins the advantages listed above.</p>
<p>This document describes our current approach to meeting all those requirements on Android. Other platforms
such as iOS are not considered.</p>
<h2 id="aar-dependency-graph"><a class="header" href="#aar-dependency-graph">AAR Dependency Graph</a></h2>
<p>We publish a separate AAR for each component (e.g. fxaclient, places, logins) which contains
<em>just</em> the Kotlin wrappers that expose the relevant functionality to Android. Each of these AARs depends on a separate
shared &quot;megazord&quot; AAR in which all the rust code has been compiled together into a single <code>.so</code> file.
The application's dependency graph thus looks like this:</p>
<p><a href="https://docs.google.com/drawings/d/1owo4wo2F1ePlCq2NS0LmAOG4jRoT_eVBahGNeWHuhJY/"><img src="https://docs.google.com/drawings/d/e/2PACX-1vTA6wL3ibJRNjKXsmescTfKTx0w_fpr5NcDIF_4T5AsnZfCi8UEEcav8vibocSyKpHOQOk5ysiDBm-D/pub?w=727&amp;h=546" alt="megazord dependency diagram" /></a></p>
<p>This generates a kind of strange inversion of dependencies in our build pipeline:</p>
<ul>
<li>Each individual component defines both a rust crate and an Android AAR.</li>
<li>There is a special &quot;full-megazord&quot; component that also defines a rust crate and an Android AAR.</li>
<li>The full-megazord rust crate depends on the rust crates for each individual component.</li>
<li>But the Android AAR for each component depends on the Android AAR of the full-megazord!</li>
</ul>
<p>It's a little odd, but it has the benefit that we can use gradle's dependency-replacement features to easily
manage the rust code that is shipping in each application.</p>
<h2 id="custom-megazords"><a class="header" href="#custom-megazords">Custom Megazords</a></h2>
<p>By default, an application that uses <em>any</em> appservices component will include the compiled rust code
for <em>all</em> appservices components.</p>
<p>To reduce its overall code size, the application can use gradle's <a href="https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html#sec:module_replacement">module replacement
rules</a>
to replace the &quot;full-megazord&quot; AAR with a custom-built megazord AAR containing only the components it requires.
Such an AAR can be built in the same way as the &quot;full-megazord&quot;, and simply avoid depending on the rust
crates for components that are not required.</p>
<p>To help ensure this replacement is done safely at runtime, the <code>mozilla.appservices.support.native</code> package
provides helper functions for loading the correct megazord <code>.so</code> file.  The Kotlin wrapper for each component
should load its shared library by calling <code>mozilla.appservices.support.native.loadIndirect</code>, specifying both
the name of the component and the expected version number of the shared library.</p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>The full-megazord AAR contains compiled rust code that targets various Android platforms, and is not
suitable for running on a Desktop development machine. In order to support integration with unittest
suites such as robolectric, each megazord has a corresponding Java ARchive (JAR) distribution named e.g.
<code>full-megazord-forUnitTests.jar</code>. This contains the rust code compiled for various Desktop architectures,
and consumers can add it to their classpath when running tests on a Desktop machine.</p>
<h2 id="gotchas-and-rough-edges"><a class="header" href="#gotchas-and-rough-edges">Gotchas and Rough Edges</a></h2>
<p>This setup mostly works, but has a handful of rough edges.</p>
<p>The <code>build.gradle</code> for each component needs to declare an explicit dependency on <code>project(&quot;:full-megazord&quot;)</code>,
otherwise the resulting AAR will not be able to locate the compiled rust code at runtime. It also needs to
declare a dependency between its build task and that of the full-megazord, for reasons. Typically this looks something
like:</p>
<pre><code>tasks[&quot;generate${productFlavor}${buildType}Assets&quot;].dependsOn(project(':full-megazord').tasks[&quot;cargoBuild&quot;])
</code></pre>
<p>In order for unit tests to work correctly, the <code>build.gradle</code> for each component needs to add the <code>rustJniLibs</code>
directory of the full-megazord project to its <code>srcDirs</code>, otherwise the unittests will not be able to find and load
the compiled rust code. Typically this looks something like:</p>
<pre><code>test.resources.srcDirs += &quot;${project(':full-megazord').buildDir}/rustJniLibs/desktop&quot;
</code></pre>
<p>The above also means that unittests will not work correctly when doing local composite builds,
because it's unreasonable to expect the main project (e.g. Fenix) to include the above in its build scripts.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/design/megazords.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="application-services-build-and-publish-pipeline"><a class="header" href="#application-services-build-and-publish-pipeline">Application Services Build and Publish Pipeline</a></h2>
<p>This document provides an overview of the build-and-publish pipeline used to make our work
in this repo available to consuming applications. It's intended both to document the pipeline
for development and maintenance purposes, and to serve as a basic analysis of the integrity
protections that it offers (so you'll notice there are notes and open questions in place where
we haven't fully hashed out all those details).</p>
<p>The key points:</p>
<ul>
<li>We use &quot;stable&quot; <a href="https://www.rust-lang.org/">Rust</a>. CI is pinned to whatever version is currently used on mozilla-central
to help with vendoring into that repository. You should check what current values are
specified for <a href="../.circleci/config.yml">CircleCI</a> and for <a href="../taskcluster/scripts/toolchain/rustup-setup.sh">TaskCluster</a></li>
<li>We use <a href="https://github.com/rust-lang/cargo">Cargo</a> for building and testing the core Rust code in isolation,
<a href="https://gradle.org/">Gradle</a> with <a href="https://github.com/mozilla/rust-android-gradle">rust-android-gradle</a>
for combining Rust and Kotlin code into Android components and running tests against them,
and <a href="https://github.com/Carthage/Carthage">Carthage</a> driving <a href="../xconfig">XCode</a>
for combining Rust and Swift code into iOS components.</li>
<li><a href="../automation/taskcluster/README.html">TaskCluster</a> runs on every pull-request, release,
and push to main, to ensure Android artifacts build correctly and to execute their
tests via gradle.</li>
<li><a href="../.circleci/config.yml">CircleCI</a> runs on every branch, pull-request (including forks), and release,
to execute lint checks and automated tests at the Rust and Swift level.</li>
<li>Releases are made by <a href="./howtos/cut-a-new-release.html">manually creating a new release</a> via github,
which triggers various CI jobs:
<ul>
<li><a href="../.circleci/config.yml">CircleCI</a> is used to build an iOS binary release on every release,
and publish it as a GitHub release artifact.</li>
<li><a href="../automation/taskcluster/README.html">TaskCluster</a> is used to:
<ul>
<li>Build an Android binary release.</li>
<li>Upload Android library symbols to <a href="https://wiki.mozilla.org/Socorro">Socorro</a>.</li>
<li>Publish it to the <a href="https://maven.mozilla.org">maven.mozilla.org</a>.</li>
</ul>
</li>
</ul>
</li>
<li>Notifications about build failures are sent to a mailing list at
<a href="https://groups.google.com/a/mozilla.com/forum/#!forum/a-s-ci-failures">a-s-ci-failures@mozilla.com</a></li>
<li>Our Taskcluster implementation is almost entirely maintained by the Release Engineering team.
The proper way to contact them in case of emergency or for new developments is to ask on the <code>#releaseduty-mobile</code> Slack channel.
Our main point of contact is @mihai.</li>
</ul>
<p>For Android consumers these are the steps by which Application Services code becomes available,
and the integrity-protection mechanisms that apply at each step:</p>
<ol>
<li>Code is developed in branches and lands on <code>main</code> via pull request.
<ul>
<li>GitHub branch protection prevents code being pushed to <code>main</code> without review.</li>
<li>CircleCI and TaskCluster run automated tests against the code, but do not have
the ability to push modified code back to GitHub thanks to the above branch protection.
<ul>
<li>TaskCluster jobs do not run against PRs opened by the general public,
only for PRs from repo collaborators.</li>
</ul>
</li>
<li>Contra the <a href="https://wiki.mozilla.org/GitHub/Repository_Security">github org security guidelines</a>,
signing of individual commits is encouraged but is <strong>not required</strong>. Our experience in practice
has been that this adds friction for contributors without sufficient tangible benefit.</li>
</ul>
</li>
<li>Developers manually create a release from latest <code>main</code>.
<ul>
<li>The ability to create new releases is managed entirely via github's permission model.</li>
<li>TODO: the <a href="https://wiki.mozilla.org/GitHub/Repository_Security">github org security guidelines</a>
recommend signing tags, and auditing all included commits as part of the release process.
We should consider some tooling to support this. I don't think there's any way to force
githib to only accept signed releases in the same way it can enforce signed commits.</li>
</ul>
</li>
<li>TaskCluster checks out the release tag, builds it for all target platforms, and runs automated tests.
<ul>
<li>These tasks run in a pre-built docker image, helping assure integrity of the build environment.</li>
<li>TODO: could this step check for signed tags as an additional integrity measure?</li>
</ul>
</li>
<li>TaskCluster uploads symbols to Socorro.
<ul>
<li>The access token for this is currently tied to @eoger's LDAP account.</li>
</ul>
</li>
<li>TaskCluster uploads built artifacts to maven.mozilla.org
<ul>
<li>Secret key for uploading to maven is provisioned via TaskCluster,
guarded by a scope that's only available to this task.</li>
<li>TODO: could a malicious dev dependency from step (3) influence the build environment here?</li>
<li>TODO: talk about how TC's &quot;chain of trust&quot; might be useful here.</li>
</ul>
</li>
<li>Consumers fetch the published artifacts from maven.mozilla.org.</li>
</ol>
<p>For iOS consumers the corresponding steps are:</p>
<ol>
<li>Code is developed in branches and lands on <code>main</code> via pull request, as above.</li>
<li>Developers manually create a release from latest <code>main</code>, as above.</li>
<li>CircleCI checks out the release tag, builds it, and runs automated tests.
<ul>
<li>TODO: These tasks bootstrap their build environment by fetching software over https.
could we do more to ensure the integrity of the build environment?</li>
<li>TODO: could this step check for signed tags as an additional integrity measure?</li>
<li>TODO: can we prevent these steps from being able to see the tokens used
for publishing in subsequent steps?</li>
</ul>
</li>
<li>CircleCI runs Carthage to assemble a zipfile of built frameworks.
<ul>
<li>TODO: could a malicious dev dependency from step (3) influence the build environment here?</li>
</ul>
</li>
<li>CircleCI uses <a href="https://github.com/travis-ci/dpl">dpl</a> to publish to GitHub as a release artifact.
<ul>
<li>CircleCI config contains a github token (owned by the @appsvc-moz GitHub account) with appropriate permissions to add release artifacts.</li>
</ul>
</li>
<li>Consumers fetch the published artifacts from GitHub during their build process,
using Carthage.</li>
</ol>
<p>It's worth noting that Carthage will <em>prefer</em> to use the built binary artifacts,
but will happily check out the tag and compile from source itself if such artifacts
are not available.</p>
<p>This is a diagram of the pipeline as it exists (and is planned) for the Nimbus SDK, one of the
libraries in Application Services:
(Source: https://miro.com/app/board/o9J_lWx3jhY=/)</p>
<p><img src="./diagrams/Nimbus-SDK-Build-and-Publish-Pipeline.jpg" alt="Nimbus SDK Build and Publish Pipeline" /></p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/build-and-publish-pipeline.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="guide-to-upgrading-nss"><a class="header" href="#guide-to-upgrading-nss">Guide to upgrading NSS</a></h1>
<p>Our components rely on cryptographic primitives provided by <a href="https://developer.mozilla.org/docs/Mozilla/Projects/NSS">NSS</a>.
Every month or so, a new version of NSS is <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_Releases">published</a> and we should try to keep our version as up-to-date as possible.</p>
<p>Because it makes unit testing easier on Android, and helps startup performance on iOS, we compile NSS ourselves and link to it statically. Note that NSS is mainly used by Mozilla as a dynamic library and the NSS project is missing related CI jobs (iOS builds, windows cross-compile builds etc.) so you should expect breakage when updating the library (hence this guide).</p>
<p>The build code is located in the <a href="https://github.com/mozilla/application-services/tree/main/libs"><code>libs/</code></a> folder.<br />
The version string is located in the beginning of <a href="https://github.com/mozilla/application-services/blob/b0b3daa6580d04906fc53e9e479e8bebb464cf78/libs/build-all.sh#L8-L11"><code>build-all.sh</code></a>. For most NSS upgrades, the only action needed is to bump the version number in this file and update the downloaded archive checksum.  The actual build invocations are located in platform-specific script files (e.g. <a href="https://github.com/mozilla/application-services/blob/b0b3daa6580d04906fc53e9e479e8bebb464cf78/libs/build-nss-ios.sh"><code>build-nss-ios.sh</code></a>)</p>
<p>On top of that, we have built a safe Rust wrapper named <a href="https://github.com/mozilla/application-services/tree/main/components/support/rc_crypto">rc_crypto</a> that links to NSS and makes these cryptographic primitives available to our components.</p>
<p>The linkage is done by the <a href="https://github.com/mozilla/application-services/blob/b0b3daa6580d04906fc53e9e479e8bebb464cf78/components/support/rc_crypto/nss/nss_build_common/src/lib.rs"><code>nss_build_common</code></a> crate. Note that it supports a <code>is_gecko</code> feature to link to NSS dynamically on Desktop.<br />
Because the NSS static build process does not output a single <code>.a</code> file (it would be great if it did), this file must <a href="https://github.com/mozilla/application-services/blob/b0b3daa6580d04906fc53e9e479e8bebb464cf78/components/support/rc_crypto/nss/nss_build_common/src/lib.rs#L85-L133">describe</a> for each architecture which modules should we link against. It is mostly a duplication of logic from the <a href="https://searchfox.org/nss/rev/d0ca572a63597a19889611c065273f131cc09b7a/lib/freebl/freebl.gyp#385-408">NSS gyp build files</a>. Note that this logic is also duplicated in our NSS lib build steps (e.g. <a href="https://github.com/mozilla/application-services/blob/b0b3daa6580d04906fc53e9e479e8bebb464cf78/libs/build-nss-desktop.sh#L82-L114">build-nss-desktop.sh</a>).</p>
<p>One of the most common build failures we get when upgrading NSS comes from NSS adding new vectorized/asm versions of a crypto algorithm for a specific architecture in order to improve performance. This new optimized code gets implemented as a new gyp target/module that is emitted only for the supported architectures.
When we upgrade our copy of NSS we notice the linking step failing on CI jobs because of undefined symbols.</p>
<p><a href="https://github.com/mozilla/application-services/pull/2476">This PR</a> shows how we update <code>nss_common_build</code> and the build scripts to accommodate for these new modules. Checking the changelog for any suspect commit relating to hardware acceleration is rumored to help.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/upgrading-nss-guide.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="metrics-collected-by-application-services-components"><a class="header" href="#metrics-collected-by-application-services-components">Metrics collected by Application Services components</a></h2>
<p>Some application-services components collect telemetry using the <a href="https://mozilla.github.io/glean/">Glean SDK</a>.
This directory contains auto-generated documentation for all such metrics.</p>
<p>Products that send telemetry via Glean <em>must request</em> a data-review following
<a href="https://wiki.mozilla.org/Firefox/Data_Collection">the Firefox Data Collection process</a>
before integrating any of the components listed below.</p>
<h3 id="components-that-collect-telemetry"><a class="header" href="#components-that-collect-telemetry">Components that collect telemetry</a></h3>
<ul>
<li><a href="metrics/./logins/metrics.html">logins</a></li>
<li><a href="metrics/./places/metrics.html">places</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><!-- AUTOGENERATED BY glean_parser.  DO NOT EDIT. -->
<h1 id="metrics"><a class="header" href="#metrics">Metrics</a></h1>
<p>This document enumerates the metrics collected by this project using the <a href="https://mozilla.github.io/glean/book/index.html">Glean SDK</a>.
This project may depend on other projects which also collect metrics.
This means you might have to go searching through the dependency tree to get a full picture of everything collected by this project.</p>
<h1 id="pings"><a class="header" href="#pings">Pings</a></h1>
<ul>
<li><a href="metrics/logins/metrics.html#metrics">metrics</a></li>
</ul>
<h2 id="metrics-1"><a class="header" href="#metrics-1">metrics</a></h2>
<p>This is a built-in ping that is assembled out of the box by the Glean SDK.</p>
<p>See the Glean SDK documentation for the <a href="https://mozilla.github.io/glean/book/user/pings/metrics.html"><code>metrics</code> ping</a>.</p>
<p>The following metrics are added to the ping:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Data reviews</th><th>Extras</th><th>Expiration</th><th><a href="https://wiki.mozilla.org/Firefox/Data_Collection">Data Sensitivity</a></th></tr></thead><tbody>
<tr><td>logins_store.read_query_count</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/counter.html">counter</a></td><td>The total number of read operations performed on the logins store. The count only includes operations triggered by the application, not e.g. incidental reads performed as part of a sync. It is intended to be used together with <code>read_query_error_count</code> to measure the overall error rate of read operations on the logins store.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1597895">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1649044">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1694316">3</a></td><td></td><td>never</td><td>2</td></tr>
<tr><td>logins_store.read_query_error_count</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html">labeled_counter</a></td><td>The total number of errors encountered during read operations on the logins store, labeled by type. It is intended to be used together with <code>read_query_count</code> to measure the overall error rate of read operations on the logins store.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1597895">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1649044">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1694316">3</a></td><td><ul><li>interrupted</li><li>storage_error</li></ul></td><td></td><td></td></tr>
<tr><td>never</td><td>2</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>logins_store.unlock_count</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/counter.html">counter</a></td><td>The number of times the login store was unlocked. It is intended to be used together with <code>unlock_error_count</code> to measure the overall error rate of unlocking the logins store.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1597895">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1649044">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1694316">3</a></td><td></td><td>never</td><td>2</td></tr>
<tr><td>logins_store.unlock_error_count</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html">labeled_counter</a></td><td>The number of errors encountered when unlocking the logins store, labeled by type. It is intended to be used together with <code>unlock_count</code> to measure the overall error rate of unlocking the logins store.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1597895">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1649044">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1694316">3</a></td><td><ul><li>invalid_key</li><li>mismatched_lock</li><li>storage_error</li></ul></td><td></td><td></td></tr>
<tr><td>never</td><td>2</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>logins_store.write_query_count</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/counter.html">counter</a></td><td>The total number of write operations performed on the logins store. The count only includes operations triggered by the application, not e.g. incidental writes performed as part of a sync. It is intended to be used together with <code>write_query_error_count</code> to measure the overall error rate of write operations on the logins store.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1597895">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1649044">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1694316">3</a></td><td></td><td>never</td><td>2</td></tr>
<tr><td>logins_store.write_query_error_count</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html">labeled_counter</a></td><td>The total number of errors encountered during write operations on the logins store, labeled by type. It is intended to be used together with <code>write_query_count</code> to measure the overall error rate of write operations on the logins store.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1597895">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1649044">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1694316">3</a></td><td><ul><li>no_such_record</li><li>id_collision</li><li>interrupted</li><li>invalid_record</li><li>storage_error</li></ul></td><td></td><td></td></tr>
<tr><td>never</td><td>2</td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<p>Data categories are <a href="https://wiki.mozilla.org/Firefox/Data_Collection">defined here</a>.</p>
<!-- AUTOGENERATED BY glean_parser.  DO NOT EDIT. -->
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/metrics/logins/metrics.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><!-- AUTOGENERATED BY glean_parser.  DO NOT EDIT. -->
<h1 id="metrics-2"><a class="header" href="#metrics-2">Metrics</a></h1>
<p>This document enumerates the metrics collected by this project using the <a href="https://mozilla.github.io/glean/book/index.html">Glean SDK</a>.
This project may depend on other projects which also collect metrics.
This means you might have to go searching through the dependency tree to get a full picture of everything collected by this project.</p>
<h1 id="pings-1"><a class="header" href="#pings-1">Pings</a></h1>
<ul>
<li><a href="metrics/places/metrics.html#metrics">metrics</a></li>
</ul>
<h2 id="metrics-3"><a class="header" href="#metrics-3">metrics</a></h2>
<p>This is a built-in ping that is assembled out of the box by the Glean SDK.</p>
<p>See the Glean SDK documentation for the <a href="https://mozilla.github.io/glean/book/user/pings/metrics.html"><code>metrics</code> ping</a>.</p>
<p>The following metrics are added to the ping:</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Data reviews</th><th>Extras</th><th>Expiration</th><th><a href="https://wiki.mozilla.org/Firefox/Data_Collection">Data Sensitivity</a></th></tr></thead><tbody>
<tr><td>places_manager.read_query_count</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/counter.html">counter</a></td><td>The total number of read operations performed on the places store. The count only includes operations triggered by the application, not e.g. incidental reads performed as part of a sync. It is intended to be used together with <code>read_query_error_count</code> to measure the overall error rate of read operations on the places store.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1607621">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1649044">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1694316">3</a></td><td></td><td>never</td><td>2</td></tr>
<tr><td>places_manager.read_query_error_count</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html">labeled_counter</a></td><td>The total number of errors encountered during read operations on the places store, labeled by type. It is intended to be used together with <code>read_query_count</code> to measure the overall error rate of read operations on the places store.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1607621">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1649044">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1694316">3</a></td><td><ul><li>url_parse_failed</li><li>operation_interrupted</li></ul></td><td></td><td></td></tr>
<tr><td>never</td><td>2</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>places_manager.write_query_count</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/counter.html">counter</a></td><td>The total number of write operations performed on the places store. The count only includes operations triggered by the application, not e.g. incidental writes performed as part of a sync. It is intended to be used together with <code>write_query_error_count</code> to measure the overall error rate of write operations on the places store.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1607621">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1649044">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1694316">3</a></td><td></td><td>never</td><td>2</td></tr>
<tr><td>places_manager.write_query_error_count</td><td><a href="https://mozilla.github.io/glean/book/user/metrics/labeled_counters.html">labeled_counter</a></td><td>The total number of errors encountered during write operations on the places store, labeled by type. It is intended to be used together with <code>write_query_count</code> to measure the overall error rate of write operations on the places store.</td><td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1607621">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1649044">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1694316">3</a></td><td><ul><li>url_parse_failed</li><li>invalid_bookmark_update</li><li>invalid_parent</li><li>unknown_bookmark_item</li><li>url_too_long</li><li>cannot_update_root</li></ul></td><td></td><td></td></tr>
<tr><td>never</td><td>2</td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<p>Data categories are <a href="https://wiki.mozilla.org/Firefox/Data_Collection">defined here</a>.</p>
<!-- AUTOGENERATED BY glean_parser.  DO NOT EDIT. -->
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/metrics/places/metrics.md">Edit this file on GitHub.</a></footer><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="developing-documentation"><a class="header" href="#developing-documentation">Developing documentation</a></h1>
<p>The documentation in this repository pertains to the application-services library, primarily the sync and storage componets, firefox account client and the nimbus-sdk, experimentation client.</p>
<p>The markdown is converted to static HTML using <a href="https://rust-lang.github.io/mdBook/">mdbook</a>.  To add a new document, you need to add it to the SUMMARY.md file which produces the sidebar table of contents.</p>
<h2 id="building-documentation"><a class="header" href="#building-documentation">Building documentation</a></h2>
<h3 id="building-the-narrative-book-documentation"><a class="header" href="#building-the-narrative-book-documentation">Building the narrative (book) documentation</a></h3>
<p>The <code>mdbook</code> crate is required in order to build the documentation:</p>
<pre><code class="language-sh">cargo install mdbook mdbook-mermaid mdbook-open-on-gh
</code></pre>
<p>The repository documents are be built with:</p>
<pre><code class="language-sh">./tools/build.docs.sh
</code></pre>
<p>The built documentation is saved in <code>build/docs/book</code>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/adding-docs.md">Edit this file on GitHub.</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="shared/tabs.js"></script>
        
        <script type="text/javascript" src="shared/mermaid.min.js"></script>
        
        <script type="text/javascript" src="shared/mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
