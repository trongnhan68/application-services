initSidebarItems({"enum":[["EngineSyncAssociation","Defines how an engine is associated with a particular set of records on a sync storage server. It's either disconnected, or believes it is connected with a specific set of GUIDs. If the server and the engine don't agree on the exact GUIDs, the engine will assume something radical happened so it can't believe anything it thinks it knows about the state of the server (ie, it will \"reset\" then do a full reconcile)"],["ErrorKind",""],["ServiceStatus","The general status of sync - should probably be moved to the \"sync manager\" once we have one!"],["Sync15ClientResponse","A response from a GET request on a Sync15StorageClient, encapsulating all the variants users of this client needs to care about."]],"fn":[["extract_v1_state","Given a string persisted as our old GlobalState V1 struct, extract out the sync IDs for the collection, plus a string which should be used as the new \"global persisted state\" (which holds the declined engines). Returns (None, None) in early error cases (eg, invalid JSON, wrong schema version etc). Otherwise, you can expect the returned global state to be Some, even if the CollSyncIds is None (which can happen if the engine is missing, or flagged for reset)"],["sync_multiple","Sync multiple engines"],["sync_multiple_with_command_processor","Like `sync_multiple`, but specifies an optional command processor to handle commands from the clients collection. This function is called by the sync manager, which provides its own processor."],["synchronize",""]],"mod":[["changeset",""],["clients",""],["telemetry","Note: this mostly just reexports the things from sync15_traits::telemetry."]],"struct":[["BsoRecord",""],["CollState","Holds state for a collection. In general, only the CollState is needed to sync a collection (but a valid GlobalState is needed to obtain a CollState)"],["CollSyncIds",""],["CollectionKeys",""],["CollectionRequest",""],["EncryptedPayload",""],["Error",""],["GlobalState","Holds global Sync state, including server upload limits, the last-fetched collection modified times, `meta/global` record, and encrypted copies of the crypto/keys resourse (which we hold as encrypted both to avoid keeping them in memory longer than necessary, and guard against the wrong (ie, a different user's) root key being passed in."],["KeyBundle",""],["MemoryCachedState","Info we want callers to engine in memory for us so that subsequent syncs are faster. This should never be persisted to storage as it holds sensitive information, such as the sync decryption keys."],["Payload","Represents the decrypted payload in a Bso. Provides a minimal layer of type safety to avoid double-encrypting."],["RecordChangeset",""],["ServerTimestamp","Typesafe way to manage server timestamps without accidentally mixing them up with local ones."],["SetupStateMachine",""],["Sync15StorageClient",""],["Sync15StorageClientInit",""],["SyncRequestInfo","This is essentially a bag of information that the sync manager knows, but otherwise we won't. It should probably be rethought if it gains many more fields."],["SyncResult","The result of a sync request. This too is from the \"sync manager\", but only has a fraction of the things it will have when we actually build that."]],"trait":[["SetupStorageClient","A trait containing the methods required to run through the setup state machine. This is factored out into a separate trait to make mocking easier."],["SyncEngine","A \"sync engine\" is a thing that knows how to sync. It's often implemented by a \"store\" (which is the generic term responsible for all storage associated with a component, including storage required for sync.)"]],"type":[["CleartextBso",""],["EncryptedBso",""],["IncomingChangeset",""],["OutgoingChangeset",""],["Result",""]]});